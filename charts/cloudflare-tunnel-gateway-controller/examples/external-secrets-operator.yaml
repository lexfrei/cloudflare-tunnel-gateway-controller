# External Secrets Operator integration example
#
# This example demonstrates how to use External Secrets Operator (ESO)
# to retrieve Cloudflare API tokens from external secret stores
# (AWS Secrets Manager, GCP Secret Manager, Azure Key Vault, HashiCorp Vault, etc.)
#
# Prerequisites:
#   1. Install External Secrets Operator:
#      helm repo add external-secrets https://charts.external-secrets.io
#      helm install external-secrets external-secrets/external-secrets \
#        --namespace external-secrets-system --create-namespace
#
#   2. Configure SecretStore or ClusterSecretStore for your provider
#      (see examples below for different providers)
#
#   3. Create ExternalSecret to sync API token from external store
#      (see example below)
#
#   4. Install this chart with apiTokenSecretName referencing the synced secret
#
# Usage:
#   helm install cloudflare-tunnel-gateway-controller \
#     oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \
#     --namespace cloudflare-tunnel-system \
#     --create-namespace \
#     --values external-secrets-operator.yaml

---
# Example 1: AWS Secrets Manager SecretStore
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secretsmanager
  namespace: cloudflare-tunnel-system
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      # Use IRSA (IAM Roles for Service Accounts)
      auth:
        jwt:
          serviceAccountRef:
            name: external-secrets-sa
---
# Example 2: GCP Secret Manager SecretStore
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: gcpsm-secretstore
  namespace: cloudflare-tunnel-system
spec:
  provider:
    gcpsm:
      projectID: "my-gcp-project"
      # Use Workload Identity
      auth:
        workloadIdentity:
          clusterLocation: us-central1
          clusterName: my-cluster
          serviceAccountRef:
            name: external-secrets-sa
---
# Example 3: Azure Key Vault SecretStore
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: azure-keyvault
  namespace: cloudflare-tunnel-system
spec:
  provider:
    azurekv:
      vaultUrl: "https://my-keyvault.vault.azure.net"
      # Use Workload Identity
      authType: WorkloadIdentity
      serviceAccountRef:
        name: external-secrets-sa
---
# Example 4: HashiCorp Vault SecretStore
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: vault-secretstore
  namespace: cloudflare-tunnel-system
spec:
  provider:
    vault:
      server: "https://vault.example.com"
      path: "secret"
      version: "v2"
      # Use Kubernetes auth
      auth:
        kubernetes:
          mountPath: "kubernetes"
          role: "external-secrets"
          serviceAccountRef:
            name: external-secrets-sa
---
# ExternalSecret for API token
# This syncs the Cloudflare API token from external secret store
# to a Kubernetes Secret that the chart can use
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: cloudflare-api-token
  namespace: cloudflare-tunnel-system
spec:
  # Refresh interval
  refreshInterval: 1h

  # Reference to SecretStore (choose one from examples above)
  secretStoreRef:
    name: aws-secretsmanager  # or gcpsm-secretstore, azure-keyvault, vault-secretstore
    kind: SecretStore

  # Target Kubernetes Secret
  target:
    name: cloudflare-credentials
    creationPolicy: Owner
    template:
      type: Opaque
      data:
        # Required key name for this chart
        api-token: "{{ .apiToken }}"

  # Data to fetch from external secret store
  data:
    - secretKey: apiToken
      remoteRef:
        # AWS Secrets Manager example
        key: cloudflare/tunnel-controller
        property: apiToken

        # # GCP Secret Manager example
        # key: projects/my-project/secrets/cloudflare-api-token/versions/latest

        # # Azure Key Vault example
        # key: cloudflare-api-token

        # # HashiCorp Vault example
        # key: secret/data/cloudflare
        # property: apiToken
---
# Optional: ExternalSecret for tunnel token (when using manageCloudflared)
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: cloudflare-tunnel-token
  namespace: cloudflare-tunnel-system
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secretsmanager
    kind: SecretStore
  target:
    name: cloudflare-tunnel-credentials
    creationPolicy: Owner
    template:
      type: Opaque
      data:
        tunnel-token: "{{ .tunnelToken }}"
  data:
    - secretKey: tunnelToken
      remoteRef:
        key: cloudflare/tunnel-controller
        property: tunnelToken
---
# Helm values for cloudflare-tunnel-gateway-controller
# Save this section to a separate file (e.g., values.yaml)
cloudflare:
  # Cloudflare Tunnel ID (required)
  # Get from: Zero Trust Dashboard > Networks > Tunnels
  tunnelId: "550e8400-e29b-41d4-a716-446655440000"

  # Reference to ExternalSecret-managed secret containing API token
  # The ExternalSecret above creates this secret with key: api-token
  apiTokenSecretName: "cloudflare-credentials"

# Optional: If using managed cloudflared deployment
manageCloudflared:
  enabled: true
  # Reference to ExternalSecret-managed secret containing tunnel token
  tunnelTokenSecretName: "cloudflare-tunnel-credentials"
  namespace: "cloudflare-tunnel-system"

# Recommended: Enable ServiceAccount annotations for cloud provider authentication
# This allows External Secrets Operator to authenticate to cloud secret stores
serviceAccount:
  annotations:
    # AWS IRSA example
    eks.amazonaws.com/role-arn: "arn:aws:iam::123456789012:role/cloudflare-tunnel-controller"

    # # GCP Workload Identity example
    # iam.gke.io/gcp-service-account: cloudflare-tunnel-controller@my-project.iam.gserviceaccount.com

    # # Azure Workload Identity example
    # azure.workload.identity/client-id: "12345678-1234-1234-1234-123456789012"
    # azure.workload.identity/tenant-id: "12345678-1234-1234-1234-123456789012"

# Security best practices
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 65534
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true

# High availability configuration
replicaCount: 2

podDisruptionBudget:
  enabled: true
  minAvailable: 1

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

# Network security
networkPolicy:
  enabled: true
