{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Cloudflare Tunnel Gateway Controller","text":"<p>Kubernetes controller implementing Gateway API for Cloudflare Tunnel.</p> <p>Enables routing traffic through Cloudflare Tunnel using standard Gateway API resources (Gateway, HTTPRoute, GRPCRoute).</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Standard Gateway API implementation (GatewayClass, Gateway, HTTPRoute, GRPCRoute)</li> <li>Hot reload of tunnel configuration (no cloudflared restart required)</li> <li>Optional cloudflared lifecycle management via Helm SDK</li> <li>Leader election for high availability deployments</li> <li>Multi-arch container images (amd64, arm64)</li> <li>Signed container images with cosign</li> </ul> <p>Warning</p> <p>The controller assumes exclusive ownership of the tunnel configuration. It will remove any ingress rules not managed by HTTPRoute/GRPCRoute resources. Do not use a tunnel that has manually configured routes or is shared with other systems.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># 1. Install Gateway API CRDs\nkubectl apply --filename https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.4.0/standard-install.yaml\n\n# 2. Install the controller\nhelm install cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --create-namespace \\\n  --set config.tunnelID=YOUR_TUNNEL_ID \\\n  --set config.apiToken=YOUR_API_TOKEN\n\n# 3. Create HTTPRoute to expose your service\nkubectl apply --filename - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: my-app\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - backendRefs:\n        - name: my-service\n          port: 80\nEOF\n</code></pre> <p>See Getting Started for detailed setup instructions.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"Section Description Getting Started Prerequisites, installation, and quick start guide Configuration Controller options, Helm values, GatewayClassConfig Gateway API Supported resources, examples, and limitations Guides Integration guides for AWG, external-dns, monitoring Operations Troubleshooting, metrics, and manual installation Development Architecture, contributing, and testing Reference Helm chart, CRD reference, security policy"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>GitHub Repository</li> <li>Issues</li> <li>Releases</li> </ul>"},{"location":"#license","title":"License","text":"<p>BSD 3-Clause License - see LICENSE for details.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>This section covers all configuration options for the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"configuration/#overview","title":"Overview","text":"<p>The controller can be configured at multiple levels:</p> <ol> <li>Controller Options - CLI flags and environment variables</li> <li>Helm Values - Deployment configuration via Helm chart</li> <li>GatewayClassConfig - Tunnel credentials and cloudflared settings</li> </ol>"},{"location":"configuration/#sections","title":"Sections","text":"<ul> <li> <p> Controller Options</p> <p>CLI flags, environment variables, and runtime configuration.</p> <p> Controller Options</p> </li> <li> <p> Helm Values</p> <p>Complete reference for Helm chart configuration values.</p> <p> Helm Values</p> </li> <li> <p> GatewayClassConfig</p> <p>Custom Resource for tunnel credentials and cloudflared configuration.</p> <p> GatewayClassConfig</p> </li> </ul>"},{"location":"configuration/#configuration-flow","title":"Configuration Flow","text":"<pre><code>flowchart LR\n    subgraph Kubernetes\n        GCC[GatewayClassConfig]\n        SEC[Secrets]\n    end\n\n    subgraph Controller\n        RES[ConfigResolver]\n        CONFIG[ResolvedConfig]\n        CTRL[Controllers]\n    end\n\n    GCC --&gt; RES\n    SEC --&gt; RES\n    RES --&gt; CONFIG\n    CONFIG --&gt; CTRL</code></pre>"},{"location":"configuration/#quick-reference","title":"Quick Reference","text":"Configuration Source Purpose <code>--controller-name</code> CLI flag GatewayClass controller name <code>--manage-cloudflared</code> CLI flag Enable cloudflared deployment <code>tunnelID</code> GatewayClassConfig Cloudflare Tunnel UUID <code>cloudflareCredentialsSecretRef</code> GatewayClassConfig API token secret reference <code>tunnelTokenSecretRef</code> GatewayClassConfig Tunnel token for cloudflared"},{"location":"configuration/controller/","title":"Controller Options","text":"<p>This document describes all configuration options for the controller binary. For Helm chart values, see Helm Values.</p>"},{"location":"configuration/controller/#command-line-flags","title":"Command Line Flags","text":"Flag Environment Variable Default Description <code>--gateway-class-name</code> <code>CF_GATEWAY_CLASS_NAME</code> <code>cloudflare-tunnel</code> GatewayClass name to watch <code>--controller-name</code> <code>CF_CONTROLLER_NAME</code> <code>cf.k8s.lex.la/tunnel-controller</code> Controller name for GatewayClass <code>--cluster-domain</code> <code>CF_CLUSTER_DOMAIN</code> (auto-detect) Kubernetes cluster domain <code>--metrics-addr</code> <code>CF_METRICS_ADDR</code> <code>:8080</code> Metrics endpoint address <code>--health-addr</code> <code>CF_HEALTH_ADDR</code> <code>:8081</code> Health probe endpoint address <code>--log-level</code> <code>CF_LOG_LEVEL</code> <code>info</code> Log level (debug, info, warn, error) <code>--log-format</code> <code>CF_LOG_FORMAT</code> <code>json</code> Log format (json, text) <code>--leader-elect</code> <code>CF_LEADER_ELECT</code> <code>false</code> Enable leader election for HA <code>--leader-election-namespace</code> <code>CF_LEADER_ELECTION_NAMESPACE</code> Namespace for leader election lease <code>--leader-election-name</code> <code>CF_LEADER_ELECTION_NAME</code> <code>cloudflare-tunnel-gateway-controller-leader</code> Leader election lease name"},{"location":"configuration/controller/#environment-variables","title":"Environment Variables","text":"<p>All flags can be set via environment variables with the <code>CF_</code> prefix. Dashes in flag names are replaced with underscores.</p> <p>Examples:</p> <ul> <li><code>--gateway-class-name</code> \u2192 <code>CF_GATEWAY_CLASS_NAME</code></li> <li><code>--log-level</code> \u2192 <code>CF_LOG_LEVEL</code></li> <li><code>--leader-elect</code> \u2192 <code>CF_LEADER_ELECT</code></li> </ul>"},{"location":"configuration/controller/#cluster-domain-auto-detection","title":"Cluster Domain Auto-Detection","text":"<p>The controller automatically detects the Kubernetes cluster domain from <code>/etc/resolv.conf</code> search domains. If detection fails, it falls back to <code>cluster.local</code>.</p> <p>To override auto-detection:</p> <pre><code>--cluster-domain=my-cluster.local\n</code></pre> <p>Or via environment variable:</p> <pre><code>CF_CLUSTER_DOMAIN=my-cluster.local\n</code></pre>"},{"location":"configuration/controller/#leader-election","title":"Leader Election","text":"<p>For high availability deployments with multiple controller replicas, enable leader election:</p> <pre><code>--leader-elect=true\n--leader-election-namespace=cloudflare-tunnel-system\n</code></pre> <p>Only the leader processes events; other replicas remain on standby for automatic failover.</p> <pre><code>flowchart LR\n    subgraph Replicas\n        R1[Replica 1&lt;br/&gt;Leader]\n        R2[Replica 2&lt;br/&gt;Standby]\n        R3[Replica 3&lt;br/&gt;Standby]\n    end\n\n    LEASE[(Lease)]\n\n    R1 --&gt;|holds| LEASE\n    R2 -.-&gt;|watches| LEASE\n    R3 -.-&gt;|watches| LEASE</code></pre>"},{"location":"configuration/controller/#logging","title":"Logging","text":""},{"location":"configuration/controller/#log-levels","title":"Log Levels","text":"Level Description <code>debug</code> Detailed debugging information <code>info</code> Normal operational messages <code>warn</code> Warning conditions <code>error</code> Error conditions"},{"location":"configuration/controller/#log-formats","title":"Log Formats","text":"Format Description <code>json</code> Structured JSON logs (recommended for production) <code>text</code> Human-readable text logs (useful for development) <p>Example JSON log:</p> <pre><code>{\n  \"level\": \"info\",\n  \"ts\": \"2024-01-15T10:30:00Z\",\n  \"msg\": \"HTTPRoute reconciled\",\n  \"route\": \"default/my-app\",\n  \"hostnames\": [\"app.example.com\"]\n}\n</code></pre>"},{"location":"configuration/controller/#health-endpoints","title":"Health Endpoints","text":"<p>The controller exposes health endpoints for Kubernetes probes:</p> Endpoint Port Description <code>/healthz</code> 8081 Liveness probe <code>/readyz</code> 8081 Readiness probe <p>These are used by Kubernetes to determine pod health:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /healthz\n    port: 8081\nreadinessProbe:\n  httpGet:\n    path: /readyz\n    port: 8081\n</code></pre>"},{"location":"configuration/controller/#metrics-endpoint","title":"Metrics Endpoint","text":"<p>The controller exposes Prometheus metrics on the metrics port:</p> Endpoint Port Description <code>/metrics</code> 8080 Prometheus metrics <p>See Metrics &amp; Alerting for available metrics.</p>"},{"location":"configuration/gatewayclassconfig/","title":"GatewayClassConfig","text":"<p>GatewayClassConfig is a cluster-scoped Custom Resource Definition (CRD) that provides tunnel configuration for the controller.</p>"},{"location":"configuration/gatewayclassconfig/#overview","title":"Overview","text":"<p>The GatewayClassConfig is referenced by a GatewayClass via <code>spec.parametersRef</code> and contains:</p> <ul> <li>Cloudflare credentials (API token, tunnel token)</li> <li>Tunnel ID</li> <li>cloudflared deployment settings</li> <li>AmneziaWG sidecar configuration (optional)</li> </ul>"},{"location":"configuration/gatewayclassconfig/#api-reference","title":"API Reference","text":"<pre><code>apiVersion: cf.k8s.lex.la/v1alpha1\nkind: GatewayClassConfig\nmetadata:\n  name: cloudflare-tunnel-config\nspec:\n  # Required: Cloudflare Tunnel UUID\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n\n  # Optional: Cloudflare Account ID (auto-detected if not specified)\n  accountID: \"1234567890abcdef\"\n\n  # Required: Reference to Secret containing API token\n  cloudflareCredentialsSecretRef:\n    name: cloudflare-credentials\n    # key: api-token  # Default: \"api-token\"\n\n  # Required when cloudflared.enabled=true: Tunnel token for cloudflared\n  tunnelTokenSecretRef:\n    name: cloudflare-tunnel-token\n    # key: tunnel-token  # Default: \"tunnel-token\"\n\n  # cloudflared deployment configuration\n  cloudflared:\n    enabled: true  # Default: true\n\n    # AmneziaWG sidecar (optional)\n    awg:\n      secretName: awg-config\n</code></pre>"},{"location":"configuration/gatewayclassconfig/#field-reference","title":"Field Reference","text":""},{"location":"configuration/gatewayclassconfig/#spectunnelid-required","title":"<code>spec.tunnelID</code> (required)","text":"<p>The UUID of the Cloudflare Tunnel. You can find this in the Cloudflare Zero Trust dashboard under Networks &gt; Tunnels.</p> <pre><code>spec:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n</code></pre>"},{"location":"configuration/gatewayclassconfig/#specaccountid-optional","title":"<code>spec.accountID</code> (optional)","text":"<p>The Cloudflare account ID. If not specified, it is auto-detected from the API token when the token has access to a single account.</p> <pre><code>spec:\n  accountID: \"1234567890abcdef\"\n</code></pre>"},{"location":"configuration/gatewayclassconfig/#speccloudflarecredentialssecretref-required","title":"<code>spec.cloudflareCredentialsSecretRef</code> (required)","text":"<p>Reference to a Kubernetes Secret containing the Cloudflare API token.</p> <pre><code>spec:\n  cloudflareCredentialsSecretRef:\n    name: cloudflare-credentials\n    key: api-token  # Optional, defaults to \"api-token\"\n</code></pre> <p>The referenced Secret must exist in the same namespace as the controller:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudflare-credentials\n  namespace: cloudflare-tunnel-system\ntype: Opaque\nstringData:\n  api-token: \"YOUR_API_TOKEN\"\n</code></pre>"},{"location":"configuration/gatewayclassconfig/#spectunneltokensecretref-required-when-cloudflaredenabledtrue","title":"<code>spec.tunnelTokenSecretRef</code> (required when <code>cloudflared.enabled=true</code>)","text":"<p>Reference to a Kubernetes Secret containing the tunnel token for cloudflared.</p> <pre><code>spec:\n  tunnelTokenSecretRef:\n    name: cloudflare-tunnel-token\n    key: tunnel-token  # Optional, defaults to \"tunnel-token\"\n</code></pre>"},{"location":"configuration/gatewayclassconfig/#speccloudflared-optional","title":"<code>spec.cloudflared</code> (optional)","text":"<p>Configuration for the cloudflared deployment.</p>"},{"location":"configuration/gatewayclassconfig/#speccloudflaredenabled","title":"<code>spec.cloudflared.enabled</code>","text":"<p>Whether the controller should deploy cloudflared via Helm. Default: <code>true</code>.</p> <p>Set to <code>false</code> if you manage cloudflared externally.</p>"},{"location":"configuration/gatewayclassconfig/#speccloudflaredawgsecretname","title":"<code>spec.cloudflared.awg.secretName</code>","text":"<p>Name of the Secret containing AmneziaWG configuration for traffic obfuscation.</p> <p>See AmneziaWG Sidecar Guide for details.</p>"},{"location":"configuration/gatewayclassconfig/#gatewayclass-reference","title":"GatewayClass Reference","text":"<p>The GatewayClass references the GatewayClassConfig via <code>parametersRef</code>:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: cloudflare-tunnel\nspec:\n  controllerName: cf.k8s.lex.la/tunnel-controller\n  parametersRef:\n    group: cf.k8s.lex.la\n    kind: GatewayClassConfig\n    name: cloudflare-tunnel-config\n</code></pre>"},{"location":"configuration/gatewayclassconfig/#complete-example","title":"Complete Example","text":"<pre><code>---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudflare-credentials\n  namespace: cloudflare-tunnel-system\ntype: Opaque\nstringData:\n  api-token: \"YOUR_API_TOKEN\"\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudflare-tunnel-token\n  namespace: cloudflare-tunnel-system\ntype: Opaque\nstringData:\n  tunnel-token: \"YOUR_TUNNEL_TOKEN\"\n---\napiVersion: cf.k8s.lex.la/v1alpha1\nkind: GatewayClassConfig\nmetadata:\n  name: cloudflare-tunnel-config\nspec:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n  cloudflareCredentialsSecretRef:\n    name: cloudflare-credentials\n  tunnelTokenSecretRef:\n    name: cloudflare-tunnel-token\n  cloudflared:\n    enabled: true\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: cloudflare-tunnel\nspec:\n  controllerName: cf.k8s.lex.la/tunnel-controller\n  parametersRef:\n    group: cf.k8s.lex.la\n    kind: GatewayClassConfig\n    name: cloudflare-tunnel-config\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: cloudflare-tunnel\n  namespace: cloudflare-tunnel-system\nspec:\n  gatewayClassName: cloudflare-tunnel\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n</code></pre>"},{"location":"configuration/gatewayclassconfig/#configuration-resolution","title":"Configuration Resolution","text":"<p>The controller resolves configuration in the following order:</p> <pre><code>flowchart LR\n    subgraph Kubernetes\n        GCC[GatewayClassConfig]\n        SEC[Secrets]\n    end\n\n    subgraph Controller\n        RES[ConfigResolver]\n        CONFIG[ResolvedConfig]\n        CTRL[Controllers]\n    end\n\n    GCC --&gt; RES\n    SEC --&gt; RES\n    RES --&gt; CONFIG\n    CONFIG --&gt; CTRL</code></pre> <ol> <li>GatewayClass references GatewayClassConfig via <code>parametersRef</code></li> <li>Controller reads GatewayClassConfig</li> <li>Controller fetches referenced Secrets</li> <li>Controller auto-detects account ID if not specified</li> <li>Resolved configuration is used by controllers</li> </ol>"},{"location":"configuration/gatewayclassconfig/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/gatewayclassconfig/#config-not-found","title":"Config Not Found","text":"<p>If the controller cannot find the GatewayClassConfig:</p> <pre><code>kubectl get gatewayclassconfig cloudflare-tunnel-config\n</code></pre> <p>Check that the name matches the <code>parametersRef.name</code> in GatewayClass.</p>"},{"location":"configuration/gatewayclassconfig/#secret-not-found","title":"Secret Not Found","text":"<p>If the controller cannot find referenced Secrets:</p> <pre><code>kubectl get secret cloudflare-credentials --namespace cloudflare-tunnel-system\n</code></pre> <p>Ensure Secrets exist in the controller's namespace.</p>"},{"location":"configuration/gatewayclassconfig/#account-id-detection-failed","title":"Account ID Detection Failed","text":"<p>If auto-detection fails, specify <code>accountID</code> explicitly:</p> <pre><code>spec:\n  accountID: \"YOUR_ACCOUNT_ID\"\n</code></pre> <p>You can find your account ID in the Cloudflare dashboard URL or via API.</p>"},{"location":"configuration/helm-values/","title":"Helm Values","text":"<p>This document provides an overview of the Helm chart configuration. For the complete reference, see the Helm Chart README.</p>"},{"location":"configuration/helm-values/#quick-reference","title":"Quick Reference","text":""},{"location":"configuration/helm-values/#essential-values","title":"Essential Values","text":"<pre><code># Cloudflare Tunnel configuration\nconfig:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n  apiToken: \"your-api-token\"\n  tunnelToken: \"your-tunnel-token\"\n  # accountID: \"auto-detected\"  # Optional, auto-detected from API token\n</code></pre>"},{"location":"configuration/helm-values/#using-existing-secrets","title":"Using Existing Secrets","text":"<p>For production deployments, use existing secrets instead of inline values:</p> <pre><code>config:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n  existingSecrets:\n    apiToken:\n      name: cloudflare-credentials\n      key: api-token\n    tunnelToken:\n      name: cloudflare-tunnel-token\n      key: tunnel-token\n</code></pre>"},{"location":"configuration/helm-values/#controller-configuration","title":"Controller Configuration","text":"<pre><code>controller:\n  replicas: 2\n\n  resources:\n    limits:\n      memory: 128Mi\n    requests:\n      cpu: 100m\n      memory: 64Mi\n\n  # Controller flags\n  extraArgs:\n    - --log-level=debug\n</code></pre>"},{"location":"configuration/helm-values/#cloudflared-configuration","title":"cloudflared Configuration","text":"<pre><code>cloudflared:\n  enabled: true  # Set to false to manage cloudflared externally\n  replicas: 2\n\n  resources:\n    limits:\n      memory: 256Mi\n    requests:\n      cpu: 100m\n      memory: 128Mi\n</code></pre>"},{"location":"configuration/helm-values/#high-availability","title":"High Availability","text":"<pre><code>controller:\n  replicas: 2\n  leaderElection:\n    enabled: true\n\ncloudflared:\n  replicas: 2\n\npodDisruptionBudget:\n  enabled: true\n  minAvailable: 1\n</code></pre>"},{"location":"configuration/helm-values/#prometheus-monitoring","title":"Prometheus Monitoring","text":"<pre><code>serviceMonitor:\n  enabled: true\n  interval: 30s\n  labels:\n    release: prometheus\n</code></pre>"},{"location":"configuration/helm-values/#common-configurations","title":"Common Configurations","text":""},{"location":"configuration/helm-values/#minimal-production-setup","title":"Minimal Production Setup","text":"<pre><code>config:\n  tunnelID: \"YOUR_TUNNEL_ID\"\n  existingSecrets:\n    apiToken:\n      name: cloudflare-credentials\n      key: api-token\n    tunnelToken:\n      name: cloudflare-tunnel-token\n      key: tunnel-token\n\ncontroller:\n  replicas: 2\n  leaderElection:\n    enabled: true\n  resources:\n    limits:\n      memory: 128Mi\n    requests:\n      cpu: 100m\n      memory: 64Mi\n\ncloudflared:\n  replicas: 2\n  resources:\n    limits:\n      memory: 256Mi\n    requests:\n      cpu: 100m\n      memory: 128Mi\n\nserviceMonitor:\n  enabled: true\n</code></pre>"},{"location":"configuration/helm-values/#development-setup","title":"Development Setup","text":"<pre><code>config:\n  tunnelID: \"YOUR_TUNNEL_ID\"\n  apiToken: \"YOUR_API_TOKEN\"\n  tunnelToken: \"YOUR_TUNNEL_TOKEN\"\n\ncontroller:\n  replicas: 1\n  extraArgs:\n    - --log-level=debug\n    - --log-format=text\n\ncloudflared:\n  replicas: 1\n</code></pre>"},{"location":"configuration/helm-values/#external-cloudflared","title":"External cloudflared","text":"<p>When managing cloudflared separately (e.g., on edge nodes):</p> <pre><code>config:\n  tunnelID: \"YOUR_TUNNEL_ID\"\n  existingSecrets:\n    apiToken:\n      name: cloudflare-credentials\n      key: api-token\n\ncloudflared:\n  enabled: false  # Don't deploy cloudflared via Helm\n</code></pre>"},{"location":"configuration/helm-values/#with-amneziawg-sidecar","title":"With AmneziaWG Sidecar","text":"<pre><code>config:\n  tunnelID: \"YOUR_TUNNEL_ID\"\n  existingSecrets:\n    apiToken:\n      name: cloudflare-credentials\n      key: api-token\n    tunnelToken:\n      name: cloudflare-tunnel-token\n      key: tunnel-token\n\ncloudflared:\n  awg:\n    enabled: true\n    secretName: awg-config\n</code></pre> <p>See AmneziaWG Sidecar Guide for details.</p>"},{"location":"configuration/helm-values/#upgrading","title":"Upgrading","text":"<p>When upgrading the Helm release:</p> <pre><code>helm upgrade cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --values values.yaml\n</code></pre> <p>Version Pinning</p> <p>Pin to specific versions in production:</p> <pre><code>helm upgrade cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --version 0.8.0 \\\n  --namespace cloudflare-tunnel-system \\\n  --values values.yaml\n</code></pre>"},{"location":"configuration/helm-values/#full-reference","title":"Full Reference","text":"<p>For the complete list of all available values with descriptions, see the Helm Chart README.</p>"},{"location":"development/","title":"Development","text":"<p>This section covers development setup, architecture, and contribution guidelines for the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"development/#overview","title":"Overview","text":"<p>The controller is built with:</p> <ul> <li>Go - Primary programming language</li> <li>controller-runtime - Kubernetes controller framework</li> <li>Helm SDK - For cloudflared deployment management</li> <li>Cloudflare Go SDK - For tunnel configuration API</li> </ul>"},{"location":"development/#sections","title":"Sections","text":"<ul> <li> <p> Setup</p> <p>Development environment setup and build commands.</p> <p> Setup</p> </li> <li> <p> Architecture</p> <p>System architecture, components, and data flow.</p> <p> Architecture</p> </li> <li> <p> Contributing</p> <p>Contribution guidelines and code review process.</p> <p> Contributing</p> </li> <li> <p> Testing</p> <p>Testing standards, patterns, and commands.</p> <p> Testing</p> </li> </ul>"},{"location":"development/#quick-start","title":"Quick Start","text":"<pre><code># Clone repository\ngit clone https://github.com/lexfrei/cloudflare-tunnel-gateway-controller.git\ncd cloudflare-tunnel-gateway-controller\n\n# Build binary\ngo build -o bin/controller ./cmd/controller\n\n# Run tests\ngo test -v -race ./...\n\n# Run linter\ngolangci-lint run --timeout=5m\n</code></pre>"},{"location":"development/#project-structure","title":"Project Structure","text":"<pre><code>api/v1alpha1/            # GatewayClassConfig CRD types\ncmd/controller/          # Entrypoint and CLI\ninternal/\n  config/                # GatewayClassConfig resolver\n  controller/            # Kubernetes controllers\n  dns/                   # Cluster domain detection\n  helm/                  # Helm SDK operations\n  ingress/               # Route to ingress conversion\ncharts/                  # Helm chart\ndeploy/                  # Raw Kubernetes manifests\n</code></pre>"},{"location":"development/#code-quality","title":"Code Quality","text":"<p>All changes must pass:</p> <ul> <li><code>go test -race ./...</code> - Unit tests with race detection</li> <li><code>golangci-lint run</code> - Linting (all errors must be fixed)</li> <li><code>markdownlint-cli2 '**/*.md'</code> - Markdown linting</li> </ul>"},{"location":"development/architecture/","title":"Architecture","text":"<p>This document describes the internal architecture of the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"development/architecture/#high-level-overview","title":"High-Level Overview","text":"<p>The controller implements the Kubernetes Gateway API to configure Cloudflare Tunnel ingress rules. It watches Gateway and HTTPRoute resources and translates them into Cloudflare Tunnel configuration via the Cloudflare API.</p> <pre><code>flowchart TB\n    subgraph Kubernetes[\"Kubernetes Cluster\"]\n        GW[Gateway]\n        HR[HTTPRoute]\n        SVC[Services]\n        CTRL[Controller]\n        CFD[cloudflared]\n    end\n\n    subgraph Cloudflare[\"Cloudflare Edge\"]\n        API[Cloudflare API]\n        EDGE[Edge Network]\n    end\n\n    GW --&gt;|watch| CTRL\n    HR --&gt;|watch| CTRL\n    SVC --&gt;|resolve| CTRL\n    CTRL --&gt;|configure| API\n    API --&gt;|push config| CFD\n    CFD --&gt;|tunnel| EDGE\n    EDGE --&gt;|traffic| CFD\n    CFD --&gt;|route| SVC</code></pre>"},{"location":"development/architecture/#package-structure","title":"Package Structure","text":"<pre><code>api/v1alpha1/            # GatewayClassConfig CRD types\n\ncmd/controller/\n\u251c\u2500\u2500 main.go              # Entry point, version injection\n\u2514\u2500\u2500 cmd/\n    \u2514\u2500\u2500 root.go          # CLI flags, Cobra command\n\ninternal/\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 resolver.go      # GatewayClassConfig resolution from Secrets\n\u251c\u2500\u2500 controller/\n\u2502   \u251c\u2500\u2500 manager.go       # Controller manager setup, Run()\n\u2502   \u251c\u2500\u2500 gateway_controller.go    # Gateway reconciler\n\u2502   \u251c\u2500\u2500 httproute_controller.go  # HTTPRoute reconciler\n\u2502   \u2514\u2500\u2500 gatewayclassconfig_controller.go  # GatewayClassConfig reconciler\n\u251c\u2500\u2500 dns/\n\u2502   \u2514\u2500\u2500 detect.go        # Cluster domain auto-detection\n\u251c\u2500\u2500 ingress/\n\u2502   \u2514\u2500\u2500 builder.go       # HTTPRoute \u2192 Cloudflare rules conversion\n\u2514\u2500\u2500 helm/\n    \u251c\u2500\u2500 manager.go       # Helm SDK operations\n    \u251c\u2500\u2500 cloudflared.go   # cloudflared chart values builder\n    \u2514\u2500\u2500 constants.go     # Chart reference, timeouts\n</code></pre>"},{"location":"development/architecture/#components","title":"Components","text":""},{"location":"development/architecture/#gatewayclassconfig","title":"GatewayClassConfig","text":"<p>Cluster-scoped Custom Resource Definition (CRD) that provides tunnel configuration:</p> <ul> <li>API Group: <code>cf.k8s.lex.la/v1alpha1</code></li> <li>Referenced by: GatewayClass via <code>spec.parametersRef</code></li> <li>Configuration: Cloudflare credentials, tunnel ID, cloudflared settings</li> </ul> <pre><code>apiVersion: cf.k8s.lex.la/v1alpha1\nkind: GatewayClassConfig\nmetadata:\n  name: cloudflare-tunnel-config\nspec:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n  cloudflareCredentialsSecretRef:\n    name: cloudflare-credentials\n  tunnelTokenSecretRef:\n    name: cloudflare-tunnel-token\n  cloudflared:\n    enabled: true\n    awg:\n      secretName: awg-config  # Optional: enables AWG sidecar\n</code></pre>"},{"location":"development/architecture/#configresolver","title":"ConfigResolver","text":"<p>Resolves GatewayClassConfig from GatewayClass <code>parametersRef</code>:</p> <ol> <li>Reads GatewayClassConfig by name from parametersRef</li> <li>Fetches Cloudflare credentials from referenced Secret</li> <li>Fetches tunnel token from referenced Secret (if cloudflared.enabled)</li> <li>Auto-detects account ID via Cloudflare API if not specified</li> </ol>"},{"location":"development/architecture/#gatewayreconciler","title":"GatewayReconciler","text":"<p>Watches Gateway resources and performs the following:</p> <ol> <li>Filtering: Only processes Gateways with matching <code>gatewayClassName</code></li> <li>Finalizers: Adds finalizer for cleanup when Helm management is enabled</li> <li>Helm Management: Deploys/upgrades cloudflared via Helm chart</li> <li>Status Update: Sets Gateway address to <code>&lt;tunnel-id&gt;.cfargotunnel.com</code></li> </ol> <pre><code>sequenceDiagram\n    participant K8s as Kubernetes API\n    participant GR as GatewayReconciler\n    participant Helm as Helm Manager\n    participant CF as Cloudflare\n\n    K8s-&gt;&gt;GR: Gateway created/updated\n    GR-&gt;&gt;GR: Check GatewayClass match\n    alt Helm Management Enabled\n        GR-&gt;&gt;GR: Add finalizer\n        GR-&gt;&gt;Helm: Install/Upgrade cloudflared\n        Helm-&gt;&gt;K8s: Deploy cloudflared pods\n    end\n    GR-&gt;&gt;K8s: Update Gateway status\n    Note over K8s: status.addresses = [tunnel-id.cfargotunnel.com]</code></pre>"},{"location":"development/architecture/#httproutereconciler","title":"HTTPRouteReconciler","text":"<p>Watches HTTPRoute resources and synchronizes them to Cloudflare:</p> <ol> <li>Filtering: Only processes routes referencing managed Gateways</li> <li>Full Sync: On any change, rebuilds entire tunnel configuration</li> <li>API Update: Pushes configuration to Cloudflare API</li> <li>Status Update: Sets route acceptance conditions</li> </ol> <pre><code>sequenceDiagram\n    participant K8s as Kubernetes API\n    participant HR as HTTPRouteReconciler\n    participant Builder as Ingress Builder\n    participant CF as Cloudflare API\n\n    K8s-&gt;&gt;HR: HTTPRoute changed\n    HR-&gt;&gt;K8s: List all HTTPRoutes\n    HR-&gt;&gt;HR: Filter by GatewayClass\n    HR-&gt;&gt;Builder: Build ingress rules\n    Builder-&gt;&gt;Builder: Sort by priority\n    Builder--&gt;&gt;HR: Cloudflare ingress config\n    HR-&gt;&gt;CF: Update tunnel configuration\n    CF--&gt;&gt;HR: Success\n    HR-&gt;&gt;K8s: Update HTTPRoute status</code></pre>"},{"location":"development/architecture/#ingress-builder","title":"Ingress Builder","text":"<p>Converts HTTPRoute specs to Cloudflare Tunnel ingress rules:</p> HTTPRoute Field Cloudflare Rule Field <code>spec.hostnames[]</code> <code>hostname</code> <code>rules[].matches[].path</code> <code>path</code> (with wildcard for prefix) <code>rules[].backendRefs[]</code> <code>service</code> (cluster DNS URL) <p>Rule Ordering:</p> <ol> <li>Alphabetically by hostname</li> <li>Exact matches before prefix matches</li> <li>Longer paths before shorter paths</li> </ol>"},{"location":"development/architecture/#helm-manager","title":"Helm Manager","text":"<p>Manages cloudflared deployment lifecycle:</p> <ul> <li>Chart Source: <code>oci://ghcr.io/lexfrei/charts/cloudflare-tunnel</code></li> <li>Auto-upgrade: Detects and upgrades to latest stable version</li> <li>Values Builder: Configures tunnel token, protocol, AWG sidecar</li> </ul>"},{"location":"development/architecture/#data-flow","title":"Data Flow","text":""},{"location":"development/architecture/#configuration-flow","title":"Configuration Flow","text":"<pre><code>flowchart LR\n    subgraph Kubernetes\n        GCC[GatewayClassConfig]\n        SEC[Secrets]\n    end\n\n    subgraph Controller\n        RES[ConfigResolver]\n        CONFIG[ResolvedConfig]\n        CTRL[Controllers]\n    end\n\n    GCC --&gt; RES\n    SEC --&gt; RES\n    RES --&gt; CONFIG\n    CONFIG --&gt; CTRL</code></pre>"},{"location":"development/architecture/#reconciliation-flow","title":"Reconciliation Flow","text":"<pre><code>flowchart TB\n    START([Watch Event]) --&gt; CHECK{GatewayClass&lt;br/&gt;matches?}\n    CHECK --&gt;|No| SKIP[Skip]\n    CHECK --&gt;|Yes| DELETED{Resource&lt;br/&gt;deleted?}\n\n    DELETED --&gt;|Yes| CLEANUP[Cleanup]\n    DELETED --&gt;|No| RECONCILE[Reconcile]\n\n    RECONCILE --&gt; SYNC[Sync to Cloudflare]\n    SYNC --&gt; STATUS[Update Status]\n\n    CLEANUP --&gt; FINALIZER[Remove Finalizer]\n\n    STATUS --&gt; END([Complete])\n    FINALIZER --&gt; END\n    SKIP --&gt; END</code></pre>"},{"location":"development/architecture/#error-handling","title":"Error Handling","text":"<p>The controller follows these error handling patterns:</p> <ol> <li>Retryable Errors: Return <code>ctrl.Result{Requeue: true}</code> for transient    failures</li> <li>Permanent Errors: Log error and update resource status condition</li> <li>API Errors: Wrapped with context using <code>cockroachdb/errors</code></li> <li>Not Found: Silently ignore (resource was deleted)</li> </ol>"},{"location":"development/architecture/#leader-election","title":"Leader Election","text":"<p>When running multiple replicas for high availability:</p> <ul> <li>Only one replica is the active leader</li> <li>Leader acquires lease in <code>coordination.k8s.io/leases</code></li> <li>Other replicas wait in standby mode</li> <li>Automatic failover on leader failure</li> </ul> <pre><code>flowchart LR\n    subgraph Replicas\n        R1[Replica 1&lt;br/&gt;Leader]\n        R2[Replica 2&lt;br/&gt;Standby]\n        R3[Replica 3&lt;br/&gt;Standby]\n    end\n\n    LEASE[(Lease)]\n\n    R1 --&gt;|holds| LEASE\n    R2 -.-&gt;|watches| LEASE\n    R3 -.-&gt;|watches| LEASE</code></pre>"},{"location":"development/architecture/#security-considerations","title":"Security Considerations","text":"Aspect Implementation API Token Stored in Kubernetes Secret, mounted as environment variable RBAC Minimal permissions following least-privilege principle Network Controller only needs egress to Cloudflare API Container Runs as non-root user (UID 65534) with read-only filesystem"},{"location":"development/architecture/#key-dependencies","title":"Key Dependencies","text":"<ul> <li><code>sigs.k8s.io/controller-runtime</code> - Kubernetes controller framework</li> <li><code>sigs.k8s.io/gateway-api</code> - Gateway API types</li> <li><code>github.com/cloudflare/cloudflare-go/v4</code> - Cloudflare API client</li> <li><code>helm.sh/helm/v3</code> - Helm SDK for cloudflared deployment</li> <li><code>github.com/cockroachdb/errors</code> - Error wrapping</li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to the Cloudflare Tunnel Gateway Controller!</p>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful and constructive in all interactions. We welcome contributors of all experience levels.</p>"},{"location":"development/contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"development/contributing/#reporting-issues","title":"Reporting Issues","text":"<ul> <li>Search existing issues before creating a new one</li> <li>Use the issue templates for bug reports and feature requests</li> <li>Provide as much detail as possible (versions, logs, reproduction steps)</li> </ul>"},{"location":"development/contributing/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch from <code>master</code></li> <li>Make your changes</li> <li>Ensure tests pass and linting is clean</li> <li>Submit a pull request</li> </ol>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":"<p>See Setup for detailed instructions.</p> <p>Quick start:</p> <pre><code>git clone https://github.com/lexfrei/cloudflare-tunnel-gateway-controller.git\ncd cloudflare-tunnel-gateway-controller\ngo mod download\ngo build ./...\ngolangci-lint run\n</code></pre>"},{"location":"development/contributing/#commit-message-format","title":"Commit Message Format","text":"<p>We use Conventional Commits:</p> <pre><code>type(scope): brief description\n\nOptional longer explanation.\n\nCo-Authored-By: Your Name &lt;your@email.com&gt;\n</code></pre>"},{"location":"development/contributing/#types","title":"Types","text":"Type Description <code>feat</code> New feature <code>fix</code> Bug fix <code>docs</code> Documentation changes <code>style</code> Code style changes (formatting) <code>refactor</code> Code refactoring <code>test</code> Adding or updating tests <code>chore</code> Maintenance tasks <code>ci</code> CI/CD changes <code>perf</code> Performance improvements <code>build</code> Build system changes"},{"location":"development/contributing/#examples","title":"Examples","text":"<pre><code>feat(controller): add support for GRPCRoute\n\nfix(ingress): handle empty hostnames correctly\n\ndocs(readme): add installation instructions\n\nchore(deps): update controller-runtime to v0.22.4\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Title: Use conventional commit format</li> <li>Description: Fill out the PR template completely</li> <li>Tests: Add tests for new functionality</li> <li>Linting: Ensure <code>golangci-lint run</code> passes with no errors</li> <li>Documentation: Update relevant docs</li> <li>Review: Address reviewer feedback</li> </ol>"},{"location":"development/contributing/#testing-pr-changes","title":"Testing PR Changes","text":"<p>Each PR automatically builds test artifacts. Links to test container images and Helm chart are posted as a comment on the PR, allowing you to test changes before merging.</p>"},{"location":"development/contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li> Code follows project style guidelines</li> <li> Tests added/updated for changes</li> <li> Documentation updated</li> <li> Commit messages follow conventional format</li> <li> All CI checks pass</li> <li> PR description is complete</li> </ul>"},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#go-code","title":"Go Code","text":"<ul> <li>Follow standard Go conventions</li> <li>Use <code>golangci-lint</code> for linting (config in <code>.golangci.yaml</code>)</li> <li>Maximum function length: 60 lines</li> <li>Maximum cyclomatic complexity: 15</li> <li>Add godoc comments to exported types and functions</li> </ul>"},{"location":"development/contributing/#linting","title":"Linting","text":"<p>All linting errors must be fixed before merging:</p> <pre><code># Run linter\ngolangci-lint run\n\n# Auto-fix some issues\ngolangci-lint run --fix\n</code></pre>"},{"location":"development/contributing/#nolint-directives","title":"nolint Directives","text":"<p>If you must disable a linter, always provide an explanation:</p> <pre><code>//nolint:funlen // controller setup requires multiple initialization steps\nfunc Run(ctx context.Context, cfg *Config) error {\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<pre><code># All tests\ngo test -v ./...\n\n# With race detector\ngo test -race ./...\n\n# With coverage\ngo test -coverprofile=coverage.out ./...\n</code></pre>"},{"location":"development/contributing/#helm-chart-tests","title":"Helm Chart Tests","text":"<pre><code>helm unittest charts/cloudflare-tunnel-gateway-controller\n</code></pre>"},{"location":"development/contributing/#test-requirements","title":"Test Requirements","text":"<ul> <li>Unit tests for new functionality</li> <li>Table-driven tests preferred</li> <li>Mock external dependencies</li> <li>Test error cases</li> </ul>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#what-to-document","title":"What to Document","text":"<ul> <li>New features in README.md</li> <li>API changes in Gateway API docs</li> <li>Configuration options</li> <li>Breaking changes</li> </ul>"},{"location":"development/contributing/#documentation-style","title":"Documentation Style","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Keep formatting consistent with existing docs</li> </ul>"},{"location":"development/contributing/#release-process","title":"Release Process","text":"<p>Releases are automated via GitHub Actions:</p> <ol> <li>Version is determined by commit messages (semantic versioning)</li> <li>Container images are built and pushed to GHCR</li> <li>Helm chart is published to OCI registry</li> <li>GitHub Release is created with changelog</li> </ol>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Open an issue for questions</li> <li>Check existing documentation in <code>docs/</code></li> <li>Review closed issues for similar problems</li> </ul>"},{"location":"development/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the BSD 3-Clause License.</p>"},{"location":"development/setup/","title":"Development Setup","text":"<p>This guide covers setting up a development environment for the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"development/setup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.25.4 or later</li> <li>kubectl configured with cluster access</li> <li>A Kubernetes cluster (kind, minikube, or remote)</li> <li>Cloudflare account with a tunnel configured</li> <li>golangci-lint (for linting)</li> </ul>"},{"location":"development/setup/#quick-start","title":"Quick Start","text":"<pre><code># Clone the repository\ngit clone https://github.com/lexfrei/cloudflare-tunnel-gateway-controller.git\ncd cloudflare-tunnel-gateway-controller\n\n# Install dependencies\ngo mod download\n\n# Build\ngo build -o bin/controller ./cmd/controller\n\n# Run tests\ngo test -v ./...\n\n# Run linter\ngolangci-lint run\n</code></pre>"},{"location":"development/setup/#building","title":"Building","text":""},{"location":"development/setup/#binary","title":"Binary","text":"<pre><code># Development build\ngo build -o bin/controller ./cmd/controller\n\n# Production build with version info\nVERSION=v0.1.0\nGITSHA=$(git rev-parse HEAD)\ngo build -ldflags \"-s -w -X main.Version=${VERSION} -X main.Gitsha=${GITSHA}\" \\\n  -trimpath -o bin/controller ./cmd/controller\n</code></pre>"},{"location":"development/setup/#container-image","title":"Container Image","text":"<pre><code># Build with podman\npodman build --tag cloudflare-tunnel-gateway-controller:dev --file Containerfile .\n\n# Build with docker\ndocker build --tag cloudflare-tunnel-gateway-controller:dev --file Containerfile .\n\n# Multi-arch build\ndocker buildx build --platform linux/amd64,linux/arm64 \\\n  --tag ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller:dev \\\n  --file Containerfile .\n</code></pre>"},{"location":"development/setup/#running-locally","title":"Running Locally","text":""},{"location":"development/setup/#with-kubeconfig","title":"With kubeconfig","text":"<pre><code># Set required environment variables\nexport CF_TUNNEL_ID=\"your-tunnel-id\"\nexport CF_API_TOKEN=\"your-api-token\"\n\n# Run controller\n./bin/controller \\\n  --log-level=debug \\\n  --log-format=text \\\n  --gateway-class-name=cloudflare-tunnel\n</code></pre>"},{"location":"development/setup/#in-cluster-development","title":"In Cluster (Development)","text":"<pre><code># Install Gateway API CRDs\nkubectl apply --filename https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.4.0/standard-install.yaml\n\n# Create namespace\nkubectl create namespace cloudflare-tunnel-system\n\n# Create secret with credentials\nkubectl create secret generic cloudflare-credentials \\\n  --namespace=cloudflare-tunnel-system \\\n  --from-literal=api-token=\"${CF_API_TOKEN}\"\n\n# Apply RBAC\nkubectl apply --filename deploy/rbac/\n\n# Run controller locally against cluster\n./bin/controller \\\n  --tunnel-id=\"${CF_TUNNEL_ID}\" \\\n  --log-level=debug\n</code></pre>"},{"location":"development/setup/#linting","title":"Linting","text":"<p>The project uses golangci-lint with strict configuration:</p> <pre><code># Run linter\ngolangci-lint run\n\n# Run with timeout for CI\ngolangci-lint run --timeout=5m\n\n# Auto-fix issues\ngolangci-lint run --fix\n</code></pre>"},{"location":"development/setup/#key-linter-settings","title":"Key Linter Settings","text":"Linter Setting Description <code>funlen</code> max 60 Maximum function length <code>gocyclo</code> max 15 Maximum cyclomatic complexity <code>gosec</code> enabled Security checks <code>nolintlint</code> enabled Requires <code>//nolint</code> explanations"},{"location":"development/setup/#debugging","title":"Debugging","text":""},{"location":"development/setup/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>./bin/controller --log-level=debug --log-format=text\n</code></pre>"},{"location":"development/setup/#inspect-controller-state","title":"Inspect Controller State","text":"<pre><code># Check Gateway status\nkubectl get gateway --all-namespaces --output yaml\n\n# Check HTTPRoute status\nkubectl get httproute --all-namespaces --output yaml\n\n# Check controller logs\nkubectl logs --namespace cloudflare-tunnel-system \\\n  deployment/cloudflare-tunnel-gateway-controller\n\n# Check events\nkubectl get events --namespace cloudflare-tunnel-system \\\n  --sort-by='.lastTimestamp'\n</code></pre>"},{"location":"development/setup/#debug-with-delve","title":"Debug with Delve","text":"<pre><code># Install delve\ngo install github.com/go-delve/delve/cmd/dlv@latest\n\n# Run with debugger\ndlv debug ./cmd/controller -- \\\n  --tunnel-id=\"${CF_TUNNEL_ID}\" \\\n  --log-level=debug\n</code></pre>"},{"location":"development/setup/#ide-setup","title":"IDE Setup","text":""},{"location":"development/setup/#vs-code","title":"VS Code","text":"<p>Recommended extensions:</p> <ul> <li>Go (golang.go)</li> <li>YAML (redhat.vscode-yaml)</li> <li>Kubernetes (ms-kubernetes-tools.vscode-kubernetes-tools)</li> </ul> <p>Settings (<code>.vscode/settings.json</code>):</p> <pre><code>{\n  \"go.lintTool\": \"golangci-lint\",\n  \"go.lintFlags\": [\"--fast\"],\n  \"go.useLanguageServer\": true,\n  \"gopls\": {\n    \"ui.semanticTokens\": true\n  }\n}\n</code></pre>"},{"location":"development/setup/#goland","title":"GoLand","text":"<ol> <li>Enable golangci-lint integration:</li> <li>Settings \u2192 Go \u2192 Linters \u2192 Enable golangci-lint</li> <li>Configure run configuration:</li> <li>Add environment variables: <code>CF_TUNNEL_ID</code>, <code>CF_API_TOKEN</code></li> <li>Set working directory to project root</li> </ol>"},{"location":"development/setup/#common-tasks","title":"Common Tasks","text":""},{"location":"development/setup/#add-a-new-flag","title":"Add a New Flag","text":"<ol> <li> <p>Add flag in <code>cmd/controller/cmd/root.go</code>:</p> <pre><code>rootCmd.Flags().String(\"my-flag\", \"default\", \"Description\")\n</code></pre> </li> <li> <p>Add viper binding and default:</p> <pre><code>viper.SetDefault(\"my-flag\", \"default\")\n</code></pre> </li> <li> <p>Add to <code>controller.Config</code> struct in <code>internal/controller/manager.go</code></p> </li> <li> <p>Pass value in <code>runController()</code> function</p> </li> </ol>"},{"location":"development/setup/#update-dependencies","title":"Update Dependencies","text":"<pre><code># Update all dependencies\ngo get -u ./...\ngo mod tidy\n\n# Update specific dependency\ngo get -u github.com/cloudflare/cloudflare-go/v4@latest\ngo mod tidy\n</code></pre>"},{"location":"development/setup/#helm-chart-versioning","title":"Helm Chart Versioning","text":"<p>Do Not Manually Bump Versions</p> <p>Do not manually change <code>version</code> or <code>appVersion</code> in <code>Chart.yaml</code>. The release workflow automatically sets both values based on the release tag. Manual changes will cause conflicts.</p>"},{"location":"development/setup/#generate-godoc","title":"Generate Godoc","text":"<pre><code>godoc -http=:6060\n# Open http://localhost:6060/pkg/github.com/lexfrei/cloudflare-tunnel-gateway-controller/\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>This guide covers testing standards and practices for the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<pre><code># Run all tests\ngo test -v ./...\n\n# Run with race detector\ngo test -race ./...\n\n# Run specific package\ngo test -v -race ./internal/controller/...\n\n# Run specific test\ngo test -v -race ./internal/controller/... -run TestHTTPRouteReconciler\n</code></pre>"},{"location":"development/testing/#coverage","title":"Coverage","text":"<pre><code># Generate coverage report\ngo test -coverprofile=coverage.out ./...\n\n# View coverage in browser\ngo tool cover -html=coverage.out\n\n# View coverage in terminal\ngo tool cover -func=coverage.out\n</code></pre>"},{"location":"development/testing/#helm-chart-tests","title":"Helm Chart Tests","text":"<pre><code># Install helm-unittest plugin\nhelm plugin install https://github.com/helm-unittest/helm-unittest\n\n# Run chart tests\nhelm unittest charts/cloudflare-tunnel-gateway-controller\n\n# Lint chart\nhelm lint charts/cloudflare-tunnel-gateway-controller\n\n# Template locally (for debugging)\nhelm template test charts/cloudflare-tunnel-gateway-controller \\\n  --values charts/cloudflare-tunnel-gateway-controller/examples/basic-values.yaml\n</code></pre>"},{"location":"development/testing/#test-patterns","title":"Test Patterns","text":""},{"location":"development/testing/#table-driven-tests","title":"Table-Driven Tests","text":"<p>Use table-driven tests with named test cases:</p> <pre><code>func TestFeature(t *testing.T) {\n    t.Parallel()\n\n    tests := []struct {\n        name     string\n        input    InputType\n        expected OutputType\n        wantErr  bool\n    }{\n        {\n            name:     \"valid input\",\n            input:    InputType{...},\n            expected: OutputType{...},\n            wantErr:  false,\n        },\n        {\n            name:     \"invalid input\",\n            input:    InputType{...},\n            expected: OutputType{},\n            wantErr:  true,\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            t.Parallel()\n\n            result, err := DoSomething(tt.input)\n\n            if tt.wantErr {\n                require.Error(t, err)\n                return\n            }\n\n            require.NoError(t, err)\n            assert.Equal(t, tt.expected, result)\n        })\n    }\n}\n</code></pre>"},{"location":"development/testing/#parallel-execution","title":"Parallel Execution","text":"<p>Always use <code>t.Parallel()</code> at test and subtest level:</p> <pre><code>func TestSomething(t *testing.T) {\n    t.Parallel()  // Mark test as parallel\n\n    t.Run(\"subtest\", func(t *testing.T) {\n        t.Parallel()  // Mark subtest as parallel\n        // ...\n    })\n}\n</code></pre>"},{"location":"development/testing/#fake-client-setup","title":"Fake Client Setup","text":"<p>Use controller-runtime fake client for unit tests:</p> <pre><code>func TestController(t *testing.T) {\n    // Create scheme with all required types\n    scheme := runtime.NewScheme()\n    _ = clientgoscheme.AddToScheme(scheme)\n    _ = gatewayv1.Install(scheme)\n\n    // Create fake client with initial objects\n    client := fake.NewClientBuilder().\n        WithScheme(scheme).\n        WithObjects(\n            &amp;gatewayv1.Gateway{...},\n            &amp;gatewayv1.HTTPRoute{...},\n        ).\n        Build()\n\n    // Create reconciler with fake client\n    reconciler := &amp;HTTPRouteReconciler{\n        Client: client,\n        Scheme: scheme,\n    }\n\n    // Test reconciliation\n    result, err := reconciler.Reconcile(ctx, ctrl.Request{...})\n    require.NoError(t, err)\n}\n</code></pre>"},{"location":"development/testing/#test-libraries","title":"Test Libraries","text":"Library Usage <code>github.com/stretchr/testify/assert</code> Soft assertions (test continues) <code>github.com/stretchr/testify/require</code> Hard assertions (test stops) <code>sigs.k8s.io/controller-runtime/pkg/client/fake</code> Fake Kubernetes client <code>sigs.k8s.io/controller-runtime/pkg/envtest</code> Integration tests"},{"location":"development/testing/#assert-vs-require","title":"Assert vs Require","text":"<pre><code>// Use require for setup and critical checks (stops test on failure)\nrequire.NoError(t, err, \"setup should succeed\")\n\n// Use assert for multiple checks (test continues)\nassert.Equal(t, expected.Name, actual.Name)\nassert.Equal(t, expected.Port, actual.Port)\n</code></pre>"},{"location":"development/testing/#test-organization","title":"Test Organization","text":""},{"location":"development/testing/#file-naming","title":"File Naming","text":"Pattern Description <code>*_test.go</code> Test files (standard Go convention) <code>*_internal_test.go</code> Tests for unexported functions (same package)"},{"location":"development/testing/#test-helpers","title":"Test Helpers","text":"<p>Extract common setup into helper functions:</p> <pre><code>func setupFakeClient(t *testing.T, objs ...client.Object) client.Client {\n    t.Helper()\n\n    scheme := runtime.NewScheme()\n    require.NoError(t, clientgoscheme.AddToScheme(scheme))\n    require.NoError(t, gatewayv1.Install(scheme))\n\n    return fake.NewClientBuilder().\n        WithScheme(scheme).\n        WithObjects(objs...).\n        Build()\n}\n</code></pre>"},{"location":"development/testing/#what-to-test","title":"What to Test","text":""},{"location":"development/testing/#unit-tests_1","title":"Unit Tests","text":"<ul> <li>Business logic functions</li> <li>Input validation</li> <li>Error handling paths</li> <li>Edge cases (empty inputs, nil values)</li> </ul>"},{"location":"development/testing/#integration-tests","title":"Integration Tests","text":"<ul> <li>Controller reconciliation loops</li> <li>Kubernetes API interactions</li> <li>Cloudflare API interactions (mocked)</li> </ul>"},{"location":"development/testing/#not-tested","title":"Not Tested","text":"<ul> <li>Generated code (CRD types, mocks)</li> <li>Third-party library internals</li> </ul>"},{"location":"development/testing/#mocking","title":"Mocking","text":""},{"location":"development/testing/#external-services","title":"External Services","text":"<p>Mock external services (Cloudflare API) in unit tests:</p> <pre><code>type mockCloudflareClient struct {\n    tunnelConfig *cloudflare.TunnelConfiguration\n    err          error\n}\n\nfunc (m *mockCloudflareClient) UpdateTunnelConfiguration(\n    ctx context.Context,\n    config cloudflare.TunnelConfiguration,\n) error {\n    m.tunnelConfig = &amp;config\n    return m.err\n}\n</code></pre>"},{"location":"development/testing/#time-dependent-tests","title":"Time-Dependent Tests","text":"<p>Use injectable time for deterministic tests:</p> <pre><code>type Clock interface {\n    Now() time.Time\n}\n\n// In production\ntype RealClock struct{}\nfunc (RealClock) Now() time.Time { return time.Now() }\n\n// In tests\ntype FakeClock struct {\n    CurrentTime time.Time\n}\nfunc (c FakeClock) Now() time.Time { return c.CurrentTime }\n</code></pre>"},{"location":"development/testing/#ci-integration","title":"CI Integration","text":"<p>Tests run automatically in CI:</p> <pre><code># .github/workflows/pr.yaml\n- name: Run tests\n  run: go test -v -race -coverprofile=coverage.out ./...\n\n- name: Upload coverage\n  uses: codecov/codecov-action@v4\n  with:\n    files: coverage.out\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Fast tests: Unit tests should run in milliseconds</li> <li>Isolated tests: No shared state between tests</li> <li>Deterministic tests: Same input = same output</li> <li>Readable tests: Test name describes behavior</li> <li>Minimal mocking: Only mock what's necessary</li> <li>Error testing: Test error paths, not just happy paths</li> </ol>"},{"location":"gateway-api/","title":"Gateway API","text":"<p>This section documents the Gateway API implementation in the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"gateway-api/#overview","title":"Overview","text":"<p>The controller implements the Kubernetes Gateway API to configure Cloudflare Tunnel ingress rules. It watches Gateway and Route resources and translates them into Cloudflare Tunnel configuration via the Cloudflare API.</p>"},{"location":"gateway-api/#supported-resources","title":"Supported Resources","text":"Resource API Version Status GatewayClass <code>gateway.networking.k8s.io/v1</code> Supported Gateway <code>gateway.networking.k8s.io/v1</code> Supported HTTPRoute <code>gateway.networking.k8s.io/v1</code> Supported GRPCRoute <code>gateway.networking.k8s.io/v1</code> Supported TCPRoute <code>gateway.networking.k8s.io/v1alpha2</code> Not supported TLSRoute <code>gateway.networking.k8s.io/v1alpha2</code> Not supported UDPRoute <code>gateway.networking.k8s.io/v1alpha2</code> Not supported"},{"location":"gateway-api/#sections","title":"Sections","text":"<ul> <li> <p> Supported Resources</p> <p>Detailed feature support matrix for each Gateway API resource.</p> <p> Supported Resources</p> </li> <li> <p> HTTPRoute</p> <p>HTTP routing examples and configuration patterns.</p> <p> HTTPRoute</p> </li> <li> <p> GRPCRoute</p> <p>gRPC routing with service and method matching.</p> <p> GRPCRoute</p> </li> <li> <p> ReferenceGrant</p> <p>Cross-namespace backend references and security.</p> <p> ReferenceGrant</p> </li> <li> <p> Limitations</p> <p>Known limitations and workarounds.</p> <p> Limitations</p> </li> </ul>"},{"location":"gateway-api/#how-it-works","title":"How It Works","text":"<pre><code>flowchart TB\n    subgraph Kubernetes[\"Kubernetes Cluster\"]\n        GW[Gateway]\n        HR[HTTPRoute]\n        SVC[Services]\n        CTRL[Controller]\n        CFD[cloudflared]\n    end\n\n    subgraph Cloudflare[\"Cloudflare Edge\"]\n        API[Cloudflare API]\n        EDGE[Edge Network]\n    end\n\n    GW --&gt;|watch| CTRL\n    HR --&gt;|watch| CTRL\n    SVC --&gt;|resolve| CTRL\n    CTRL --&gt;|configure| API\n    API --&gt;|push config| CFD\n    CFD --&gt;|tunnel| EDGE\n    EDGE --&gt;|traffic| CFD\n    CFD --&gt;|route| SVC</code></pre>"},{"location":"gateway-api/#key-concepts","title":"Key Concepts","text":"<p>TLS Termination</p> <p>Cloudflare Tunnel terminates TLS at Cloudflare's edge network. Gateway listener configuration for ports, protocols, and TLS settings has no effect on routing behavior.</p> <p>Full Sync</p> <p>Any change to HTTPRoute or GRPCRoute triggers a full configuration sync to Cloudflare Tunnel. The controller rebuilds the entire ingress configuration on each reconciliation.</p>"},{"location":"gateway-api/grpcroute/","title":"GRPCRoute","text":"<p>GRPCRoute enables routing gRPC traffic through Cloudflare Tunnel with service and method-level matching.</p>"},{"location":"gateway-api/grpcroute/#basic-example","title":"Basic Example","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: my-grpc-service\n  namespace: default\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - grpc.example.com\n  rules:\n    - backendRefs:\n        - name: grpc-server\n          port: 50051\n</code></pre>"},{"location":"gateway-api/grpcroute/#service-routing","title":"Service Routing","text":"<p>Route by gRPC service name:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: grpc-service-routes\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - api.example.com\n  rules:\n    # Route UserService to user backend\n    - matches:\n        - method:\n            service: mypackage.UserService\n      backendRefs:\n        - name: user-service\n          port: 50051\n    # Route OrderService to order backend\n    - matches:\n        - method:\n            service: mypackage.OrderService\n      backendRefs:\n        - name: order-service\n          port: 50051\n</code></pre>"},{"location":"gateway-api/grpcroute/#method-routing","title":"Method Routing","text":"<p>Route specific gRPC methods to different backends:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: grpc-method-routes\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - api.example.com\n  rules:\n    # Exact method match - read operations\n    - matches:\n        - method:\n            service: mypackage.UserService\n            method: GetUser\n      backendRefs:\n        - name: user-read-service\n          port: 50051\n    # All other methods on the service - write operations\n    - matches:\n        - method:\n            service: mypackage.UserService\n      backendRefs:\n        - name: user-write-service\n          port: 50051\n</code></pre>"},{"location":"gateway-api/grpcroute/#method-matching","title":"Method Matching","text":"<p>gRPC methods are mapped to HTTP/2 paths using the standard format <code>/package.Service/Method</code>.</p> Match Type Example Cloudflare Rule Service only <code>service: mypackage.MyService</code> <code>/mypackage.MyService/*</code> Service + Method <code>service: mypackage.MyService, method: GetUser</code> <code>/mypackage.MyService/GetUser</code> No match (empty) Matches all gRPC traffic"},{"location":"gateway-api/grpcroute/#match-type-field","title":"Match Type Field","text":"<p>The <code>type</code> field specifies how to match:</p> Type Description <code>Exact</code> Exact string match (default) <code>RegularExpression</code> Regular expression match <pre><code>matches:\n  - method:\n      service: mypackage.UserService\n      method: Get.*\n      type: RegularExpression\n</code></pre>"},{"location":"gateway-api/grpcroute/#cross-namespace-routing","title":"Cross-Namespace Routing","text":"<p>GRPCRoute also supports cross-namespace backend references with ReferenceGrant:</p> <pre><code>---\n# ReferenceGrant in target namespace\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-grpc-routes\n  namespace: grpc-services\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: GRPCRoute\n      namespace: app-namespace\n  to:\n    - group: \"\"\n      kind: Service\n---\n# GRPCRoute in source namespace\napiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: cross-ns-grpc-route\n  namespace: app-namespace\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - grpc.example.com\n  rules:\n    - matches:\n        - method:\n            service: mypackage.UserService\n      backendRefs:\n        - name: user-grpc-service\n          namespace: grpc-services\n          port: 50051\n</code></pre>"},{"location":"gateway-api/grpcroute/#backend-selection-with-weights","title":"Backend Selection with Weights","text":"<p>When multiple backends are specified, the backend with the highest weight is selected:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: weighted-grpc\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - grpc.example.com\n  rules:\n    - matches:\n        - method:\n            service: mypackage.UserService\n      backendRefs:\n        - name: primary-grpc\n          port: 50051\n          weight: 100  # Selected\n        - name: fallback-grpc\n          port: 50051\n          weight: 0    # Disabled\n</code></pre>"},{"location":"gateway-api/grpcroute/#multiple-hostnames","title":"Multiple Hostnames","text":"<p>Route multiple gRPC endpoints:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: multi-host-grpc\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - grpc.example.com\n    - api.example.com\n    - \"*.grpc.example.com\"\n  rules:\n    - backendRefs:\n        - name: grpc-server\n          port: 50051\n</code></pre>"},{"location":"gateway-api/grpcroute/#checking-route-status","title":"Checking Route Status","text":"<p>Verify that the route is accepted:</p> <pre><code>kubectl get grpcroute my-grpc-route --output jsonpath='{.status.parents[*].conditions}'\n</code></pre>"},{"location":"gateway-api/grpcroute/#status-conditions","title":"Status Conditions","text":"Condition Meaning <code>Accepted: True</code> Route is active and synced to Cloudflare <code>Accepted: False</code> Route was rejected (check reason) <code>ResolvedRefs: True</code> All backend references resolved <code>ResolvedRefs: False</code> Backend reference failed"},{"location":"gateway-api/grpcroute/#limitations","title":"Limitations","text":""},{"location":"gateway-api/grpcroute/#not-supported","title":"Not Supported","text":"Feature Reason Header matching Cloudflare Tunnel limitation Filters Not implemented Backend filters Not implemented"},{"location":"gateway-api/grpcroute/#traffic-splitting","title":"Traffic Splitting","text":"<p>The controller does NOT implement traffic splitting. When multiple backends have weights, the highest weight backend receives 100% of traffic.</p> <p>For actual traffic splitting, deploy a gRPC-aware load balancer (e.g., Envoy) and point the GRPCRoute to it.</p>"},{"location":"gateway-api/grpcroute/#troubleshooting","title":"Troubleshooting","text":""},{"location":"gateway-api/grpcroute/#route-not-accepted","title":"Route Not Accepted","text":"<p>Check controller logs:</p> <pre><code>kubectl logs --selector app.kubernetes.io/name=cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system\n</code></pre> <p>Common causes:</p> <ul> <li>Gateway not found</li> <li>Cloudflare API error</li> <li>Invalid method specification</li> </ul>"},{"location":"gateway-api/grpcroute/#grpc-connection-issues","title":"gRPC Connection Issues","text":"<ol> <li>Verify cloudflared is running and connected:</li> </ol> <pre><code>kubectl logs --selector app=cloudflared \\\n  --namespace cloudflare-tunnel-system\n</code></pre> <ol> <li>Check that the backend service supports gRPC (HTTP/2):</li> </ol> <pre><code>kubectl describe service grpc-server\n</code></pre> <ol> <li>Verify the backend pod is listening on the correct port:</li> </ol> <pre><code>kubectl port-forward svc/grpc-server 50051:50051\ngrpcurl --plaintext localhost:50051 list\n</code></pre>"},{"location":"gateway-api/httproute/","title":"HTTPRoute","text":"<p>HTTPRoute is the primary resource for configuring HTTP routing through Cloudflare Tunnel.</p>"},{"location":"gateway-api/httproute/#basic-example","title":"Basic Example","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: my-app\n  namespace: default\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /\n      backendRefs:\n        - name: my-service\n          port: 80\n</code></pre>"},{"location":"gateway-api/httproute/#path-based-routing","title":"Path-Based Routing","text":"<p>Route different paths to different services:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: api-routes\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - api.example.com\n  rules:\n    # Exact match takes priority\n    - matches:\n        - path:\n            type: Exact\n            value: /health\n      backendRefs:\n        - name: health-service\n          port: 8080\n    # Prefix match for API v1\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /v1\n      backendRefs:\n        - name: api-v1\n          port: 8080\n    # Prefix match for API v2\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /v2\n      backendRefs:\n        - name: api-v2\n          port: 8080\n</code></pre>"},{"location":"gateway-api/httproute/#path-match-types","title":"Path Match Types","text":"Type Example Cloudflare Rule Description <code>PathPrefix</code> <code>/api</code> <code>/api*</code> Matches paths starting with value <code>Exact</code> <code>/health</code> <code>/health</code> Matches exact path only"},{"location":"gateway-api/httproute/#multiple-hostnames","title":"Multiple Hostnames","text":"<p>Route multiple hostnames to the same service:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: multi-host\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n    - www.example.com\n    - \"*.staging.example.com\"\n  rules:\n    - backendRefs:\n        - name: web-app\n          port: 80\n</code></pre> <p>Wildcard SSL</p> <p>Multi-level subdomains like <code>*.staging.example.com</code> require Advanced Certificate Manager for SSL certificates.</p>"},{"location":"gateway-api/httproute/#backend-selection-with-weights","title":"Backend Selection with Weights","text":"<p>When multiple backends are specified, the backend with the highest weight is selected:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: weighted-backend\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - backendRefs:\n        # Backend with highest weight is selected\n        - name: primary-service\n          port: 80\n          weight: 80\n        - name: fallback-service\n          port: 80\n          weight: 20\n        # primary-service is selected (weight 80 &gt; 20)\n</code></pre> <p>Not Traffic Splitting</p> <p>This is NOT traffic splitting. The controller always sends 100% of traffic to the selected backend. For traffic splitting, deploy a dedicated load balancer.</p>"},{"location":"gateway-api/httproute/#cross-namespace-routing","title":"Cross-Namespace Routing","text":"<p>Route to services in different namespaces using ReferenceGrant:</p> <pre><code>---\n# ReferenceGrant in target namespace\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-app-to-backend\n  namespace: backend-namespace\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: app-namespace\n  to:\n    - group: \"\"\n      kind: Service\n---\n# HTTPRoute in source namespace\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: cross-ns-route\n  namespace: app-namespace\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - myapp.example.com\n  rules:\n    - backendRefs:\n        - name: backend-service\n          namespace: backend-namespace\n          port: 8080\n</code></pre> <p>See ReferenceGrant for more details.</p>"},{"location":"gateway-api/httproute/#externalname-service-backends","title":"ExternalName Service Backends","text":"<p>Route traffic to external services using Kubernetes ExternalName Services:</p> <pre><code>---\n# ExternalName Service pointing to external API\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-api\n  namespace: default\nspec:\n  type: ExternalName\n  externalName: api.external.com\n---\n# HTTPRoute using ExternalName Service\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: external-route\n  namespace: default\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - myapp.example.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /external\n      backendRefs:\n        - name: external-api\n          port: 443\n</code></pre> <p>The controller resolves ExternalName Services and routes traffic directly to the external hostname (<code>api.external.com:443</code> in this example).</p> <p>Port and Scheme</p> <p>The scheme (<code>http</code> or <code>https</code>) is determined by the port: port 443 uses HTTPS, all other ports use HTTP.</p>"},{"location":"gateway-api/httproute/#external-dns-integration","title":"External-DNS Integration","text":"<p>Add annotations for automatic DNS record creation:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: with-dns\n  annotations:\n    external-dns.alpha.kubernetes.io/cloudflare-proxied: \"true\"\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - auto-dns.example.com\n  rules:\n    - backendRefs:\n        - name: my-service\n          port: 80\n</code></pre> <p>See External-DNS Integration for setup.</p>"},{"location":"gateway-api/httproute/#listener-section-matching","title":"Listener Section Matching","text":"<p>Target specific Gateway listeners using <code>sectionName</code>:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: specific-listener\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n      sectionName: http  # Match listener name\n  hostnames:\n    - app.example.com\n  rules:\n    - backendRefs:\n        - name: my-service\n          port: 80\n</code></pre>"},{"location":"gateway-api/httproute/#checking-route-status","title":"Checking Route Status","text":"<p>Verify that the route is accepted:</p> <pre><code>kubectl get httproute my-app --output jsonpath='{.status.parents[*].conditions}'\n</code></pre> <p>Expected output includes <code>\"type\":\"Accepted\",\"status\":\"True\"</code>.</p>"},{"location":"gateway-api/httproute/#common-status-conditions","title":"Common Status Conditions","text":"Condition Meaning <code>Accepted: True</code> Route is active and synced to Cloudflare <code>Accepted: False</code> Route was rejected (check reason) <code>ResolvedRefs: True</code> All backend references resolved <code>ResolvedRefs: False</code> Backend reference failed (missing service or ReferenceGrant)"},{"location":"gateway-api/httproute/#troubleshooting","title":"Troubleshooting","text":""},{"location":"gateway-api/httproute/#route-not-accepted","title":"Route Not Accepted","text":"<p>Check controller logs:</p> <pre><code>kubectl logs --selector app.kubernetes.io/name=cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system\n</code></pre> <p>Common causes:</p> <ul> <li>Gateway not found (wrong name or namespace in parentRefs)</li> <li>Cloudflare API error (invalid credentials)</li> <li>Service not found</li> </ul>"},{"location":"gateway-api/httproute/#cross-namespace-reference-denied","title":"Cross-Namespace Reference Denied","text":"<p>Ensure ReferenceGrant exists in the target namespace and allows your route's namespace.</p> <pre><code>kubectl get referencegrant --namespace backend-namespace\n</code></pre>"},{"location":"gateway-api/limitations/","title":"Limitations","text":"<p>This document describes the known limitations of the Cloudflare Tunnel Gateway Controller and provides workarounds where applicable.</p>"},{"location":"gateway-api/limitations/#cloudflare-tunnel-constraints","title":"Cloudflare Tunnel Constraints","text":"<p>The following Gateway API features are not supported due to Cloudflare Tunnel architecture:</p> Feature Reason Header matching Tunnel ingress rules don't support header conditions Query parameter matching Tunnel ingress rules don't support query conditions Method matching Tunnel ingress rules don't support HTTP method conditions Request header modification Tunnel doesn't modify requests Response header modification Tunnel doesn't modify responses Request redirect Tunnel doesn't support redirects URL rewrite Tunnel doesn't support rewrites Request mirroring Tunnel doesn't support mirroring Traffic splitting Tunnel sends to single backend"},{"location":"gateway-api/limitations/#controller-limitations","title":"Controller Limitations","text":"Limitation Description Single backend Only highest-weight <code>backendRef</code> is used per rule Full sync Any change triggers full config sync No cross-cluster Only in-cluster services supported Service only Only <code>Service</code> kind backends (ClusterIP, NodePort, LoadBalancer, ExternalName)"},{"location":"gateway-api/limitations/#traffic-splitting-and-load-balancing","title":"Traffic Splitting and Load Balancing","text":"<p>Design Decision: This controller intentionally does not implement traffic splitting or weighted load balancing between multiple backends.</p>"},{"location":"gateway-api/limitations/#why-no-traffic-splitting","title":"Why No Traffic Splitting?","text":"<p>Cloudflare Tunnel ingress rules accept only a single service URL per rule. To support Gateway API's <code>backendRefs</code> with weights, the controller would need to:</p> <ol> <li>Create and manage intermediate Kubernetes Services</li> <li>Watch and synchronize Endpoints from all referenced services</li> <li>Handle cross-namespace references and RBAC</li> <li>Manage lifecycle of controller-created resources</li> </ol> <p>This approach introduces significant complexity, potential for orphaned resources, and creates an opaque traffic path that is difficult for users to debug.</p>"},{"location":"gateway-api/limitations/#our-approach","title":"Our Approach","text":"<p>Provide the tunnel a single, stable entrypoint. The controller selects the backend with the highest weight and sends 100% of traffic to it.</p>"},{"location":"gateway-api/limitations/#workarounds","title":"Workarounds","text":"<p>Between pods of the same Deployment:</p> <p>Use a standard Kubernetes Service (built-in round-robin load balancing):</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: my-app\nspec:\n  selector:\n    app: my-app\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre> <p>Weighted traffic splitting or canary:</p> <p>Deploy a dedicated load balancer (Traefik, Envoy, Nginx, HAProxy) and point the HTTPRoute to it:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: my-app\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - backendRefs:\n        - name: traefik  # Traefik handles weighted routing internally\n          port: 80\n</code></pre> <p>This keeps the controller simple and predictable, and gives you full control over load balancing behavior.</p>"},{"location":"gateway-api/limitations/#ssl-certificate-limitations","title":"SSL Certificate Limitations","text":"<p>Cloudflare's free Universal SSL certificates only cover root and first-level subdomains:</p> Hostname Covered Notes <code>example.com</code> Yes Root domain <code>*.example.com</code> Yes First-level wildcard <code>app.example.com</code> Yes First-level subdomain <code>app.dev.example.com</code> No Multi-level subdomain <code>*.dev.example.com</code> No Multi-level wildcard"},{"location":"gateway-api/limitations/#workaround","title":"Workaround","text":"<p>For multi-level subdomains, you need:</p> <ul> <li>Advanced Certificate Manager   ($10/month)</li> <li>Business or Enterprise plan</li> </ul>"},{"location":"gateway-api/limitations/#gateway-listener-configuration","title":"Gateway Listener Configuration","text":"<p>Gateway listeners follow Gateway API specification. Some fields are ignored because Cloudflare Tunnel manages them at the edge:</p> Field Status Notes <code>port</code> Ignored Cloudflare uses 443/80 <code>protocol</code> Ignored Cloudflare handles protocols <code>hostname</code> Supported Routes must have intersecting hostnames <code>tls</code> Ignored Cloudflare manages TLS <code>allowedRoutes</code> Supported Namespace (Same/All/Selector) and kind filtering <p>This is because Cloudflare Tunnel terminates TLS at Cloudflare's edge, not in the cluster. However, <code>hostname</code> and <code>allowedRoutes</code> are validated per Gateway API specification.</p>"},{"location":"gateway-api/limitations/#route-types-not-supported","title":"Route Types Not Supported","text":"Route Type Status Reason TCPRoute Not supported Cloudflare Tunnel is HTTP-focused TLSRoute Not supported TLS is terminated at edge UDPRoute Not supported No UDP support in tunnels"},{"location":"gateway-api/limitations/#workaround-for-tcpudp","title":"Workaround for TCP/UDP","text":"<p>For non-HTTP traffic:</p> <ol> <li>Use Cloudflare Spectrum    (separate product)</li> <li>Use a different ingress solution (LoadBalancer, NodePort)</li> </ol>"},{"location":"gateway-api/limitations/#full-sync-behavior","title":"Full Sync Behavior","text":"<p>Any change to an HTTPRoute or GRPCRoute triggers a full configuration sync to Cloudflare Tunnel. This means:</p> <ol> <li>Controller lists all HTTPRoutes and GRPCRoutes</li> <li>Filters by GatewayClass</li> <li>Rebuilds entire ingress configuration</li> <li>Pushes to Cloudflare API</li> </ol>"},{"location":"gateway-api/limitations/#implications","title":"Implications","text":"<ul> <li>More API calls than incremental updates</li> <li>Brief delay when many routes are present</li> <li>All routes are re-evaluated on any change</li> </ul>"},{"location":"gateway-api/limitations/#mitigation","title":"Mitigation","text":"<p>For large deployments:</p> <ul> <li>Batch route changes when possible</li> <li>Monitor Cloudflare API rate limits</li> <li>Consider separating high-churn routes to different tunnels</li> </ul>"},{"location":"gateway-api/limitations/#route-conflict-resolution","title":"Route Conflict Resolution","text":"<p>Routes are processed in order:</p> <ol> <li>Exact path matches first</li> <li>Longer prefix paths before shorter</li> <li>Alphabetically by hostname</li> </ol> <p>If routes conflict, the first match wins. The controller does not merge rules from different routes.</p>"},{"location":"gateway-api/limitations/#example-conflict","title":"Example Conflict","text":"<pre><code># Route A\nrules:\n  - matches:\n      - path:\n          type: PathPrefix\n          value: /api\n    backendRefs:\n      - name: api-v1\n\n# Route B\nrules:\n  - matches:\n      - path:\n          type: PathPrefix\n          value: /api/v2\n    backendRefs:\n      - name: api-v2\n</code></pre> <p>Route B's <code>/api/v2</code> matches first (longer path), then Route A's <code>/api</code> matches remaining traffic.</p>"},{"location":"gateway-api/limitations/#no-multi-cluster-support","title":"No Multi-Cluster Support","text":"<p>The controller only routes to Services within the same Kubernetes cluster. Cross-cluster routing is not supported.</p>"},{"location":"gateway-api/limitations/#workaround_1","title":"Workaround","text":"<p>For multi-cluster scenarios:</p> <ol> <li>Deploy the controller in each cluster with separate tunnels</li> <li>Use Cloudflare Load Balancing to distribute traffic between tunnels</li> <li>Consider a service mesh with cross-cluster capabilities</li> </ol>"},{"location":"gateway-api/limitations/#metrics-and-observability","title":"Metrics and Observability","text":"<p>The controller provides Prometheus metrics for monitoring, but:</p> <ul> <li>No distributed tracing integration</li> <li>No access logs (use Cloudflare dashboard)</li> <li>Limited visibility into Cloudflare API operations</li> </ul> <p>See Metrics &amp; Alerting for available metrics.</p>"},{"location":"gateway-api/referencegrant/","title":"ReferenceGrant","text":"<p>ReferenceGrant enables cross-namespace backend references in HTTPRoute and GRPCRoute resources. This is a security feature that requires explicit permission for a Route in one namespace to reference a Service in another namespace.</p>"},{"location":"gateway-api/referencegrant/#how-it-works","title":"How It Works","text":"<ol> <li>ReferenceGrant must be created in the target namespace (where the    Service is)</li> <li>It grants permission to routes in the source namespace to reference    Services in the target namespace</li> <li>Without a ReferenceGrant, cross-namespace backend references are denied    with <code>ResolvedRefs=False</code> status</li> </ol> <pre><code>flowchart LR\n    subgraph app-namespace\n        HR[HTTPRoute]\n    end\n\n    subgraph backend-namespace\n        RG[ReferenceGrant]\n        SVC[Service]\n    end\n\n    HR --&gt;|references| SVC\n    RG --&gt;|allows| HR</code></pre>"},{"location":"gateway-api/referencegrant/#basic-example","title":"Basic Example","text":"<pre><code>---\n# ReferenceGrant must be in the target namespace (where the Service is)\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-app-to-backend\n  namespace: backend-namespace  # Target namespace\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: app-namespace  # Source namespace\n  to:\n    - group: \"\"  # Core API group (empty string for Services)\n      kind: Service\n---\n# HTTPRoute in source namespace\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: cross-ns-route\n  namespace: app-namespace\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - myapp.example.com\n  rules:\n    - backendRefs:\n        - name: backend-service\n          namespace: backend-namespace  # Cross-namespace reference\n          port: 8080\n</code></pre>"},{"location":"gateway-api/referencegrant/#field-reference","title":"Field Reference","text":""},{"location":"gateway-api/referencegrant/#specfrom-required","title":"<code>spec.from</code> (required)","text":"<p>Defines which resources can reference targets in this namespace.</p> Field Description <code>group</code> API group of the referencing resource (e.g., <code>gateway.networking.k8s.io</code>) <code>kind</code> Kind of the referencing resource (<code>HTTPRoute</code> or <code>GRPCRoute</code>) <code>namespace</code> Namespace of the referencing resource"},{"location":"gateway-api/referencegrant/#specto-required","title":"<code>spec.to</code> (required)","text":"<p>Defines which resources can be referenced.</p> Field Description <code>group</code> API group of the target resource (<code>\"\"</code> for core/Services) <code>kind</code> Kind of the target resource (<code>Service</code>) <code>name</code> Optional: specific resource name (if omitted, all resources of this kind are allowed)"},{"location":"gateway-api/referencegrant/#allow-all-namespaces","title":"Allow All Namespaces","text":"<p>To allow any namespace to reference Services in this namespace:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-all-namespaces\n  namespace: shared-services\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: \"*\"  # Not supported - use multiple entries\n  to:\n    - group: \"\"\n      kind: Service\n</code></pre> <p>Wildcard Not Supported</p> <p>The Gateway API does not support wildcards in <code>namespace</code>. You must create individual entries for each namespace, or create the ReferenceGrant in each source namespace.</p>"},{"location":"gateway-api/referencegrant/#allow-specific-service","title":"Allow Specific Service","text":"<p>Restrict access to a specific Service:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-specific-service\n  namespace: backend-namespace\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: app-namespace\n  to:\n    - group: \"\"\n      kind: Service\n      name: public-api  # Only this service can be referenced\n</code></pre>"},{"location":"gateway-api/referencegrant/#multiple-source-namespaces","title":"Multiple Source Namespaces","text":"<p>Allow multiple namespaces to reference Services:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-multiple-namespaces\n  namespace: shared-services\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: frontend\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: backend\n    - group: gateway.networking.k8s.io\n      kind: GRPCRoute\n      namespace: grpc-apps\n  to:\n    - group: \"\"\n      kind: Service\n</code></pre>"},{"location":"gateway-api/referencegrant/#grpcroute-example","title":"GRPCRoute Example","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-grpc-routes\n  namespace: grpc-services\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: GRPCRoute\n      namespace: app-namespace\n  to:\n    - group: \"\"\n      kind: Service\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: cross-ns-grpc\n  namespace: app-namespace\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - grpc.example.com\n  rules:\n    - matches:\n        - method:\n            service: mypackage.UserService\n      backendRefs:\n        - name: user-grpc-service\n          namespace: grpc-services\n          port: 50051\n</code></pre>"},{"location":"gateway-api/referencegrant/#status-conditions","title":"Status Conditions","text":"<p>When a cross-namespace reference is denied, the route status shows:</p> <pre><code>status:\n  parents:\n    - parentRef:\n        name: cloudflare-tunnel\n        namespace: cloudflare-tunnel-system\n      conditions:\n        - type: ResolvedRefs\n          status: \"False\"\n          reason: RefNotPermitted\n          message: \"Cross-namespace reference not permitted by ReferenceGrant\"\n</code></pre>"},{"location":"gateway-api/referencegrant/#checking-referencegrants","title":"Checking ReferenceGrants","text":"<p>List ReferenceGrants in a namespace:</p> <pre><code>kubectl get referencegrant --namespace backend-namespace\n</code></pre> <p>View details:</p> <pre><code>kubectl describe referencegrant allow-app-to-backend --namespace backend-namespace\n</code></pre>"},{"location":"gateway-api/referencegrant/#troubleshooting","title":"Troubleshooting","text":""},{"location":"gateway-api/referencegrant/#refnotpermitted-error","title":"RefNotPermitted Error","text":"<p>Check that:</p> <ol> <li>ReferenceGrant exists in the target namespace (where Service is)</li> <li><code>from[].namespace</code> matches the route's namespace</li> <li><code>from[].kind</code> matches the route kind (HTTPRoute or GRPCRoute)</li> <li><code>from[].group</code> is <code>gateway.networking.k8s.io</code></li> <li><code>to[].group</code> is <code>\"\"</code> (empty string for core API)</li> <li><code>to[].kind</code> is <code>Service</code></li> </ol>"},{"location":"gateway-api/referencegrant/#common-mistakes","title":"Common Mistakes","text":"Mistake Fix ReferenceGrant in wrong namespace Create in target (Service) namespace Wrong <code>from.group</code> Use <code>gateway.networking.k8s.io</code> Wrong <code>to.group</code> Use <code>\"\"</code> (empty string) for Services Missing namespace in backendRef Add explicit <code>namespace</code> field"},{"location":"gateway-api/referencegrant/#debug-commands","title":"Debug Commands","text":"<pre><code># Check route status\nkubectl get httproute my-route --output jsonpath='{.status.parents[*].conditions}'\n\n# Check ReferenceGrant\nkubectl get referencegrant --namespace backend-namespace --output yaml\n\n# Check controller logs\nkubectl logs --selector app.kubernetes.io/name=cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system | grep -i reference\n</code></pre>"},{"location":"gateway-api/referencegrant/#security-considerations","title":"Security Considerations","text":"<p>Least Privilege</p> <p>Create ReferenceGrants with the minimum necessary permissions:</p> <ul> <li>Specify exact namespaces instead of multiple entries</li> <li>Use <code>to[].name</code> to restrict to specific Services when possible</li> <li>Regularly audit ReferenceGrants in shared namespaces</li> </ul> <p>Shared Namespaces</p> <p>Be careful with ReferenceGrants in namespaces containing sensitive Services. A ReferenceGrant without <code>to[].name</code> allows access to ALL Services in that namespace.</p>"},{"location":"gateway-api/supported-resources/","title":"Supported Resources","text":"<p>This document details the feature support matrix for each Gateway API resource type in the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"gateway-api/supported-resources/#resource-overview","title":"Resource Overview","text":"Resource API Version Status GatewayClass <code>gateway.networking.k8s.io/v1</code> Supported Gateway <code>gateway.networking.k8s.io/v1</code> Supported HTTPRoute <code>gateway.networking.k8s.io/v1</code> Supported GRPCRoute <code>gateway.networking.k8s.io/v1</code> Supported ReferenceGrant <code>gateway.networking.k8s.io/v1beta1</code> Supported TCPRoute <code>gateway.networking.k8s.io/v1alpha2</code> Not supported TLSRoute <code>gateway.networking.k8s.io/v1alpha2</code> Not supported UDPRoute <code>gateway.networking.k8s.io/v1alpha2</code> Not supported"},{"location":"gateway-api/supported-resources/#gatewayclass","title":"GatewayClass","text":"Field Supported Notes <code>spec.controllerName</code> Yes Must match <code>--controller-name</code> flag <code>spec.parametersRef</code> Yes Via GatewayClassConfig CRD <code>spec.description</code> Yes Informational only"},{"location":"gateway-api/supported-resources/#gateway","title":"Gateway","text":"<p>The Gateway resource is accepted. Some listener configuration (port, protocol, TLS) is ignored because Cloudflare Tunnel handles these at the edge. However, <code>hostname</code> and <code>allowedRoutes</code> are fully validated per Gateway API specification.</p> Field Supported Notes <code>spec.gatewayClassName</code> Yes Required, must match configured class <code>spec.listeners</code> Partial Accepted for compatibility, not used for routing <code>spec.listeners[].name</code> Yes Used for status reporting and sectionName matching <code>spec.listeners[].port</code> No Ignored; Cloudflare uses standard 443/80 <code>spec.listeners[].protocol</code> No Ignored; Cloudflare handles protocol negotiation <code>spec.listeners[].hostname</code> Yes Routes must have intersecting hostnames <code>spec.listeners[].tls</code> No Ignored; Cloudflare manages TLS certificates <code>spec.listeners[].allowedRoutes</code> Yes Namespace (Same/All/Selector) and kind filtering <code>spec.addresses</code> No Ignored; tunnel CNAME set automatically in status <code>spec.infrastructure</code> No Not implemented <p>TLS Termination</p> <p>Cloudflare Tunnel terminates TLS at Cloudflare's edge network. The tunnel connector (cloudflared) establishes an outbound connection to Cloudflare. Gateway listener configuration for ports, protocols, and TLS settings has no effect on routing behavior.</p>"},{"location":"gateway-api/supported-resources/#httproute","title":"HTTPRoute","text":"Field Supported Notes <code>spec.parentRefs</code> Yes References to Gateway <code>spec.parentRefs[].name</code> Yes Gateway name <code>spec.parentRefs[].namespace</code> Yes Gateway namespace <code>spec.parentRefs[].sectionName</code> Yes Listener name (optional) <code>spec.hostnames</code> Yes Wildcard <code>*</code> supported <code>spec.rules</code> Yes Routing rules <code>spec.rules[].matches</code> Partial Only path matching supported <code>spec.rules[].matches[].path</code> Yes See Path Matching <code>spec.rules[].matches[].headers</code> No Cloudflare limitation <code>spec.rules[].matches[].queryParams</code> No Cloudflare limitation <code>spec.rules[].matches[].method</code> No Cloudflare limitation <code>spec.rules[].filters</code> No Not implemented <code>spec.rules[].backendRefs</code> Yes Service backends only <code>spec.rules[].backendRefs[].name</code> Yes Service name <code>spec.rules[].backendRefs[].namespace</code> Yes Cross-namespace refs require ReferenceGrant <code>spec.rules[].backendRefs[].port</code> Yes Service port <code>spec.rules[].backendRefs[].weight</code> Yes Backend with highest weight selected <code>spec.rules[].backendRefs[].filters</code> No Not implemented <code>spec.rules[].timeouts</code> No Not implemented"},{"location":"gateway-api/supported-resources/#supported-service-types","title":"Supported Service Types","text":"Service Type Supported Notes <code>ClusterIP</code> Yes Routes via cluster-local DNS <code>NodePort</code> Yes Routes via cluster-local DNS <code>LoadBalancer</code> Yes Routes via cluster-local DNS <code>ExternalName</code> Yes Routes directly to external hostname"},{"location":"gateway-api/supported-resources/#grpcroute","title":"GRPCRoute","text":"Field Supported Notes <code>spec.parentRefs</code> Yes References to Gateway <code>spec.parentRefs[].name</code> Yes Gateway name <code>spec.parentRefs[].namespace</code> Yes Gateway namespace <code>spec.parentRefs[].sectionName</code> Yes Listener name (optional) <code>spec.hostnames</code> Yes Wildcard <code>*</code> supported <code>spec.rules</code> Yes Routing rules <code>spec.rules[].matches</code> Yes Service/method matching <code>spec.rules[].matches[].method.service</code> Yes gRPC service name <code>spec.rules[].matches[].method.method</code> Yes gRPC method name <code>spec.rules[].matches[].method.type</code> Yes Exact or RegularExpression <code>spec.rules[].matches[].headers</code> No Cloudflare limitation <code>spec.rules[].filters</code> No Not implemented <code>spec.rules[].backendRefs</code> Yes Service backends only <code>spec.rules[].backendRefs[].name</code> Yes Service name <code>spec.rules[].backendRefs[].namespace</code> Yes Cross-namespace refs require ReferenceGrant <code>spec.rules[].backendRefs[].port</code> Yes Service port <code>spec.rules[].backendRefs[].weight</code> Yes Backend with highest weight selected <code>spec.rules[].backendRefs[].filters</code> No Not implemented"},{"location":"gateway-api/supported-resources/#referencegrant","title":"ReferenceGrant","text":"<p>ReferenceGrant enables cross-namespace backend references in HTTPRoute and GRPCRoute resources.</p> Field Supported Notes <code>spec.from</code> Yes Source routes (HTTPRoute, GRPCRoute) <code>spec.from[].group</code> Yes Must be <code>gateway.networking.k8s.io</code> <code>spec.from[].kind</code> Yes Must be <code>HTTPRoute</code> or <code>GRPCRoute</code> <code>spec.from[].namespace</code> Yes Namespace where routes are located <code>spec.to</code> Yes Target resources (Services) <code>spec.to[].group</code> Yes Must be <code>\"\"</code> (core) for Services <code>spec.to[].kind</code> Yes Must be <code>Service</code> <code>spec.to[].name</code> Yes Optional; if omitted, all Services allowed <p>See ReferenceGrant for detailed examples.</p>"},{"location":"gateway-api/supported-resources/#path-matching","title":"Path Matching","text":"Type Supported Example Cloudflare Rule <code>PathPrefix</code> Yes <code>/api</code> <code>/api*</code> <code>Exact</code> Yes <code>/health</code> <code>/health</code> <code>RegularExpression</code> Partial <code>^/v[0-9]+/</code> Treated as prefix"},{"location":"gateway-api/supported-resources/#grpc-method-matching","title":"gRPC Method Matching","text":"<p>gRPC methods are mapped to HTTP/2 paths using the standard format <code>/package.Service/Method</code>.</p> Match Type Example Cloudflare Rule Service only <code>service: mypackage.MyService</code> <code>/mypackage.MyService/*</code> Service + Method <code>service: mypackage.MyService, method: GetUser</code> <code>/mypackage.MyService/GetUser</code> No match (empty) Matches all gRPC traffic"},{"location":"gateway-api/supported-resources/#weight-selection-behavior","title":"Weight Selection Behavior","text":"<p>When multiple <code>backendRefs</code> are specified in a rule, the controller selects the backend with the highest <code>weight</code> value:</p> <ul> <li>Default weight: <code>1</code> (per Gateway API specification)</li> <li>Zero weight: Backends with <code>weight: 0</code> are disabled</li> <li>Equal weights: First backend in list is selected</li> </ul> <pre><code>backendRefs:\n  - name: primary-service\n    port: 80\n    weight: 100  # Selected (highest weight)\n  - name: secondary-service\n    port: 80\n    weight: 50\n</code></pre> <p>Not Traffic Splitting</p> <p>This is NOT traffic splitting. The controller always sends 100% of traffic to the selected backend. Use weights to indicate preference, not traffic distribution.</p> <p>No Fallback on Rejection</p> <p>If the highest-weight backend is rejected (e.g., due to missing ReferenceGrant for cross-namespace reference), the controller does not fall back to the next backend. The entire rule is skipped, and the route status will show <code>ResolvedRefs=False</code>. This is per Gateway API specification \u2014 weights indicate preference, not failover order.</p>"},{"location":"gateway-api/supported-resources/#status-conditions","title":"Status Conditions","text":""},{"location":"gateway-api/supported-resources/#gateway-conditions","title":"Gateway Conditions","text":"Type Status Reason Description <code>Accepted</code> <code>True</code> <code>Accepted</code> Gateway accepted by controller <code>Programmed</code> <code>True</code> <code>Programmed</code> Gateway configured in Cloudflare"},{"location":"gateway-api/supported-resources/#gateway-listener-conditions","title":"Gateway Listener Conditions","text":"Type Status Reason Description <code>Accepted</code> <code>True</code> <code>Accepted</code> Listener accepted <code>Programmed</code> <code>True</code> <code>Programmed</code> Listener programmed <code>ResolvedRefs</code> <code>True</code> <code>ResolvedRefs</code> References resolved"},{"location":"gateway-api/supported-resources/#httproutegrpcroute-conditions","title":"HTTPRoute/GRPCRoute Conditions","text":"Type Status Reason Description <code>Accepted</code> <code>True</code> <code>Accepted</code> Route accepted and synced <code>Accepted</code> <code>False</code> <code>NoMatchingParent</code> Sync to Cloudflare failed <code>Accepted</code> <code>False</code> <code>NoMatchingListenerHostname</code> Route hostnames don't intersect with listener <code>Accepted</code> <code>False</code> <code>NotAllowedByListeners</code> Route namespace or kind not allowed by listener <code>ResolvedRefs</code> <code>True</code> <code>ResolvedRefs</code> Backend references resolved <code>ResolvedRefs</code> <code>False</code> <code>RefNotPermitted</code> Cross-namespace reference denied <code>ResolvedRefs</code> <code>False</code> <code>BackendNotFound</code> Backend Service not found"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section covers everything you need to get the Cloudflare Tunnel Gateway Controller running in your Kubernetes cluster.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>The controller enables routing traffic through Cloudflare Tunnel using standard Gateway API resources. Before installing, you need:</p> <ol> <li>A Kubernetes cluster with Gateway API CRDs installed</li> <li>A Cloudflare account with a pre-created Cloudflare Tunnel</li> <li>A Cloudflare API token with tunnel permissions</li> </ol>"},{"location":"getting-started/#sections","title":"Sections","text":"<ul> <li> <p> Prerequisites</p> <p>Required components, Cloudflare Tunnel creation, and API token setup.</p> <p> Prerequisites</p> </li> <li> <p> Installation</p> <p>Install the controller using Helm chart with all configuration options.</p> <p> Installation</p> </li> <li> <p> Quick Start</p> <p>Create your first HTTPRoute and expose a service through Cloudflare Tunnel.</p> <p> Quick Start</p> </li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>After completing the getting started guide:</p> <ul> <li>Learn about Configuration options</li> <li>Explore Gateway API features and examples</li> <li>Set up Monitoring for production deployments</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers installing the Cloudflare Tunnel Gateway Controller using Helm.</p>"},{"location":"getting-started/installation/#helm-installation","title":"Helm Installation","text":"<p>Helm is the only supported installation method. It handles CRD installation, RBAC setup, and provides a simple upgrade path.</p>"},{"location":"getting-started/installation/#basic-installation","title":"Basic Installation","text":"<pre><code>helm install cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --create-namespace \\\n  --set config.tunnelID=YOUR_TUNNEL_ID \\\n  --set config.apiToken=YOUR_API_TOKEN\n</code></pre>"},{"location":"getting-started/installation/#installation-with-values-file","title":"Installation with Values File","text":"<p>Create a <code>values.yaml</code> file:</p> <pre><code>config:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n\n  # Use existing secrets instead of inline values\n  existingSecrets:\n    apiToken:\n      name: cloudflare-credentials\n      key: api-token\n    tunnelToken:\n      name: cloudflare-tunnel-token\n      key: tunnel-token\n\n# cloudflared deployment settings\ncloudflared:\n  enabled: true\n  replicas: 2\n\n# Controller settings\ncontroller:\n  replicas: 2\n  resources:\n    limits:\n      memory: 128Mi\n    requests:\n      cpu: 100m\n      memory: 64Mi\n</code></pre> <p>Then install:</p> <pre><code>helm install cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --create-namespace \\\n  --values values.yaml\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Check that the controller is running:</p> <pre><code>kubectl get pods --namespace cloudflare-tunnel-system\n</code></pre> <p>Expected output:</p> <pre><code>NAME                                                      READY   STATUS    RESTARTS   AGE\ncloudflare-tunnel-gateway-controller-7d8f9b6c5d-x2j9k     1/1     Running   0          30s\ncloudflare-tunnel-cloudflared-5c4d8b7f6c-m8n3l            1/1     Running   0          30s\n</code></pre> <p>Check GatewayClass:</p> <pre><code>kubectl get gatewayclass cloudflare-tunnel\n</code></pre> <p>Expected output:</p> <pre><code>NAME               CONTROLLER                                   ACCEPTED   AGE\ncloudflare-tunnel  github.com/lexfrei/cloudflare-tunnel-gateway  True       30s\n</code></pre>"},{"location":"getting-started/installation/#upgrading","title":"Upgrading","text":"<p>To upgrade to a newer version:</p> <pre><code>helm upgrade cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --values values.yaml\n</code></pre>"},{"location":"getting-started/installation/#uninstalling","title":"Uninstalling","text":"<p>To remove the controller:</p> <pre><code>helm uninstall cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system\n</code></pre> <p>Cleanup</p> <p>Uninstalling the Helm release will remove the controller and cloudflared pods. The tunnel configuration in Cloudflare will remain. To fully clean up, delete the tunnel from the Cloudflare dashboard.</p>"},{"location":"getting-started/installation/#alternative-external-secrets","title":"Alternative: External Secrets","text":"<p>For production deployments, consider using external-secrets to manage Cloudflare credentials:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: cloudflare-credentials\n  namespace: cloudflare-tunnel-system\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: vault-backend\n    kind: ClusterSecretStore\n  target:\n    name: cloudflare-credentials\n  data:\n    - secretKey: api-token\n      remoteRef:\n        key: cloudflare/api-token\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After installation, proceed to Quick Start to create your first HTTPRoute.</p>"},{"location":"getting-started/prerequisites/","title":"Prerequisites","text":"<p>Before installing the Cloudflare Tunnel Gateway Controller, ensure you have the following prerequisites in place.</p>"},{"location":"getting-started/prerequisites/#kubernetes-cluster","title":"Kubernetes Cluster","text":"<p>You need a Kubernetes cluster with:</p> <ul> <li>Kubernetes version 1.25 or later</li> <li><code>kubectl</code> configured to access the cluster</li> <li>Helm 3.x installed</li> </ul>"},{"location":"getting-started/prerequisites/#gateway-api-crds","title":"Gateway API CRDs","text":"<p>The controller requires Gateway API Custom Resource Definitions (CRDs) to be installed in your cluster:</p> <pre><code>kubectl apply --filename https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.4.0/standard-install.yaml\n</code></pre> <p>Version Compatibility</p> <p>The controller is tested with Gateway API v1.4.0. Using older versions may result in missing features or compatibility issues.</p>"},{"location":"getting-started/prerequisites/#cloudflare-account","title":"Cloudflare Account","text":"<p>You need a Cloudflare account with:</p> <ul> <li>A domain managed by Cloudflare (for DNS)</li> <li>Access to Cloudflare Zero Trust dashboard</li> </ul>"},{"location":"getting-started/prerequisites/#create-cloudflare-tunnel","title":"Create Cloudflare Tunnel","text":"<p>Before deploying the controller, create a Cloudflare Tunnel:</p> <ol> <li>Go to Cloudflare Zero Trust Dashboard</li> <li>Navigate to Networks &gt; Tunnels</li> <li>Click Create a tunnel</li> <li>Choose Cloudflared connector type</li> <li>Name your tunnel and save:<ul> <li>Tunnel ID - UUID identifying the tunnel</li> <li>Tunnel Token - Used by cloudflared to authenticate</li> </ul> </li> </ol> <p>Controller vs cloudflared</p> <p>The controller manages tunnel ingress configuration via API. You can either:</p> <ul> <li>Let the controller deploy cloudflared automatically (default behavior)</li> <li>Deploy cloudflared yourself using the tunnel token   (<code>cloudflared.enabled: false</code> in Helm values)</li> </ul>"},{"location":"getting-started/prerequisites/#cloudflare-api-token","title":"Cloudflare API Token","text":"<p>Create an API token at Cloudflare API Tokens with the following permissions:</p> Scope Permission Access Account Cloudflare Tunnel Edit <p>Account ID</p> <p>Account ID is auto-detected from the API token when not explicitly provided (works if the token has access to a single account).</p>"},{"location":"getting-started/prerequisites/#creating-the-api-token","title":"Creating the API Token","text":"<ol> <li>Go to Cloudflare API Tokens</li> <li>Click Create Token</li> <li>Click Create Custom Token</li> <li>Configure the token:<ul> <li>Token name: <code>cloudflare-tunnel-gateway-controller</code></li> <li>Permissions: Account &gt; Cloudflare Tunnel &gt; Edit</li> <li>Account Resources: Include &gt; Your Account</li> </ul> </li> <li>Click Continue to summary and Create Token</li> <li>Copy the token value (you won't be able to see it again)</li> </ol>"},{"location":"getting-started/prerequisites/#secrets-preparation","title":"Secrets Preparation","text":"<p>Prepare the following secrets for the controller:</p>"},{"location":"getting-started/prerequisites/#api-token-secret","title":"API Token Secret","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudflare-credentials\n  namespace: cloudflare-tunnel-system\ntype: Opaque\nstringData:\n  api-token: \"YOUR_API_TOKEN\"\n</code></pre>"},{"location":"getting-started/prerequisites/#tunnel-token-secret-if-controller-manages-cloudflared","title":"Tunnel Token Secret (if controller manages cloudflared)","text":"<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudflare-tunnel-token\n  namespace: cloudflare-tunnel-system\ntype: Opaque\nstringData:\n  tunnel-token: \"YOUR_TUNNEL_TOKEN\"\n</code></pre>"},{"location":"getting-started/prerequisites/#next-steps","title":"Next Steps","text":"<p>Once you have all prerequisites in place, proceed to Installation.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide walks you through creating your first HTTPRoute to expose a Kubernetes service through Cloudflare Tunnel.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have completed:</p> <ul> <li>Prerequisites - Cloudflare Tunnel and API token created</li> <li>Installation - Controller installed and running</li> </ul>"},{"location":"getting-started/quickstart/#deploy-a-sample-application","title":"Deploy a Sample Application","text":"<p>First, deploy a simple application to expose:</p> <pre><code>kubectl create deployment nginx --image=nginx:latest\nkubectl expose deployment nginx --port=80\n</code></pre>"},{"location":"getting-started/quickstart/#create-an-httproute","title":"Create an HTTPRoute","text":"<p>Create an HTTPRoute to expose the nginx service through Cloudflare Tunnel:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: nginx\n  namespace: default\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - nginx.example.com  # Replace with your domain\n  rules:\n    - backendRefs:\n        - name: nginx\n          port: 80\n</code></pre> <p>Apply the route:</p> <pre><code>kubectl apply --filename httproute.yaml\n</code></pre>"},{"location":"getting-started/quickstart/#verify-the-route","title":"Verify the Route","text":"<p>Check that the HTTPRoute is accepted:</p> <pre><code>kubectl get httproute nginx --output jsonpath='{.status.parents[*].conditions}'\n</code></pre> <p>Expected output includes <code>\"type\":\"Accepted\",\"status\":\"True\"</code>.</p>"},{"location":"getting-started/quickstart/#configure-dns","title":"Configure DNS","text":"<p>The controller sets the Gateway address to <code>TUNNEL_ID.cfargotunnel.com</code>. Create a CNAME record pointing your hostname to this address:</p> Type Name Target CNAME nginx <code>YOUR_TUNNEL_ID.cfargotunnel.com</code> <p>External-DNS</p> <p>If you have external-dns configured with Gateway API source, DNS records are created automatically. See External-DNS Integration for setup.</p>"},{"location":"getting-started/quickstart/#access-your-application","title":"Access Your Application","text":"<p>Once DNS propagates, access your application at <code>https://nginx.example.com</code>.</p> <p>Cloudflare automatically provides:</p> <ul> <li>TLS certificate (via Universal SSL)</li> <li>DDoS protection</li> <li>Web Application Firewall (WAF)</li> <li>Caching (configurable)</li> </ul>"},{"location":"getting-started/quickstart/#path-based-routing","title":"Path-Based Routing","text":"<p>Route different paths to different services:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: api-routes\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - api.example.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /v1\n      backendRefs:\n        - name: api-v1\n          port: 8080\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /v2\n      backendRefs:\n        - name: api-v2\n          port: 8080\n</code></pre>"},{"location":"getting-started/quickstart/#multiple-hostnames","title":"Multiple Hostnames","text":"<p>Route multiple hostnames to the same service:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: multi-host\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n    - www.example.com\n    - \"*.staging.example.com\"\n  rules:\n    - backendRefs:\n        - name: web-app\n          port: 80\n</code></pre>"},{"location":"getting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quickstart/#route-not-accepted","title":"Route Not Accepted","text":"<p>Check controller logs:</p> <pre><code>kubectl logs --selector app.kubernetes.io/name=cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system\n</code></pre> <p>Common issues:</p> <ul> <li>Gateway not found (wrong namespace or name in parentRefs)</li> <li>Cloudflare API error (invalid credentials or permissions)</li> <li>Service not found (wrong service name or namespace)</li> </ul>"},{"location":"getting-started/quickstart/#ssl-certificate-errors","title":"SSL Certificate Errors","text":"<p>Cloudflare's free Universal SSL covers:</p> <ul> <li><code>example.com</code></li> <li><code>*.example.com</code></li> </ul> <p>For multi-level subdomains like <code>app.dev.example.com</code>, you need Advanced Certificate Manager.</p>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Configuration options</li> <li>Explore Gateway API features</li> <li>Set up Monitoring for production</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>This section contains step-by-step guides for common integration scenarios and advanced configurations.</p>"},{"location":"guides/#available-guides","title":"Available Guides","text":"<ul> <li> <p> AmneziaWG Sidecar</p> <p>Set up traffic obfuscation with AmneziaWG sidecar container.</p> <p> AmneziaWG Sidecar</p> </li> <li> <p> External-DNS Integration</p> <p>Automatic DNS record management with external-dns.</p> <p> External-DNS</p> </li> <li> <p> Cross-Namespace Routing</p> <p>Route traffic to services in different namespaces using ReferenceGrant.</p> <p> Cross-Namespace</p> </li> <li> <p> Monitoring</p> <p>Set up Prometheus metrics, Grafana dashboards, and alerting.</p> <p> Monitoring</p> </li> </ul>"},{"location":"guides/#prerequisites","title":"Prerequisites","text":"<p>Before following these guides, ensure you have:</p> <ol> <li>Completed the Getting Started guide</li> <li>A working Cloudflare Tunnel Gateway Controller installation</li> <li>Familiarity with Kubernetes and Gateway API concepts</li> </ol>"},{"location":"guides/#choosing-a-guide","title":"Choosing a Guide","text":"Use Case Recommended Guide Traffic obfuscation in restricted networks AmneziaWG Sidecar Automatic DNS record creation External-DNS Multi-namespace service mesh Cross-Namespace Routing Production observability Monitoring"},{"location":"guides/awg-sidecar/","title":"AmneziaWG Sidecar","text":"<p>This guide walks you through setting up Cloudflare Tunnel with AmneziaWG (AWG) sidecar for traffic obfuscation.</p>"},{"location":"guides/awg-sidecar/#why-awg","title":"Why AWG?","text":"<p>AmneziaWG routes cloudflared traffic through an obfuscated WireGuard tunnel, making it harder to detect and block Cloudflare Tunnel connections in restricted networks.</p>"},{"location":"guides/awg-sidecar/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Gateway API CRDs installed</li> <li>Cloudflare Tunnel created in Zero Trust Dashboard</li> <li>AWG server configured and accessible</li> </ul> <p>Single Replica Limitation</p> <p>AWG configuration contains unique client identity (private key, address). Running multiple replicas with the same config will cause connection conflicts. Currently only single replica deployments are supported.</p>"},{"location":"guides/awg-sidecar/#step-1-create-namespace","title":"Step 1: Create Namespace","text":"<pre><code>kubectl create namespace cloudflare-tunnel-system\n</code></pre>"},{"location":"guides/awg-sidecar/#step-2-create-secrets","title":"Step 2: Create Secrets","text":""},{"location":"guides/awg-sidecar/#cloudflare-api-credentials","title":"Cloudflare API Credentials","text":"<pre><code>kubectl create secret generic cloudflare-credentials \\\n  --namespace cloudflare-tunnel-system \\\n  --from-literal=api-token=\"YOUR_API_TOKEN\"\n</code></pre>"},{"location":"guides/awg-sidecar/#tunnel-token","title":"Tunnel Token","text":"<p>Get the tunnel token from: Zero Trust Dashboard &gt; Networks &gt; Tunnels &gt; Configure</p> <pre><code>kubectl create secret generic cloudflare-tunnel-token \\\n  --namespace cloudflare-tunnel-system \\\n  --from-literal=tunnel-token=\"YOUR_TUNNEL_TOKEN\"\n</code></pre>"},{"location":"guides/awg-sidecar/#awg-configuration","title":"AWG Configuration","text":"<p>Create <code>awg.conf</code> file with your AWG server configuration:</p> <pre><code>[Interface]\nAddress = 10.x.x.x/32\nPrivateKey = YOUR_PRIVATE_KEY\n# AWG-specific obfuscation parameters (get from your AWG server)\nJc = 2\nJmin = 10\nJmax = 50\nS1 = 32\nS2 = 115\nH1 = 1313297875\nH2 = 13518962\nH3 = 1721880616\nH4 = 1243767569\n\n[Peer]\nPublicKey = SERVER_PUBLIC_KEY\nPresharedKey = OPTIONAL_PRESHARED_KEY\n# IMPORTANT: AllowedIPs must include ALL Cloudflare IP ranges\nAllowedIPs = 173.245.48.0/20, 103.21.244.0/22, 103.22.200.0/22, 103.31.4.0/22, 141.101.64.0/18, 108.162.192.0/18, 190.93.240.0/20, 188.114.96.0/20, 197.234.240.0/22, 198.41.128.0/17, 162.158.0.0/15, 104.16.0.0/13, 104.24.0.0/14, 172.64.0.0/13, 131.0.72.0/22\nEndpoint = your-awg-server:port\nPersistentKeepalive = 25\n</code></pre> <p>AllowedIPs Critical</p> <p>AllowedIPs MUST include ALL Cloudflare IP ranges from https://www.cloudflare.com/ips/. Missing ranges will cause connection failures.</p> <p>Then create the secret:</p> <pre><code>kubectl create secret generic awg-config \\\n  --namespace cloudflare-tunnel-system \\\n  --from-file=wg0.conf=awg.conf\n</code></pre>"},{"location":"guides/awg-sidecar/#step-3-install-controller-with-awg","title":"Step 3: Install Controller with AWG","text":"<p>Create <code>awg-values.yaml</code>:</p> <pre><code>gatewayClassConfig:\n  create: true\n  tunnelID: \"your-tunnel-uuid\"\n  cloudflareCredentialsSecretRef:\n    name: cloudflare-credentials\n  tunnelTokenSecretRef:\n    name: cloudflare-tunnel-token\n  cloudflared:\n    enabled: true\n    awg:\n      secretName: awg-config\n\n# Required for AWG - needs NET_ADMIN capability\npodSecurityContext:\n  runAsNonRoot: false\n  runAsUser: 0\n\nsecurityContext:\n  allowPrivilegeEscalation: true\n  capabilities:\n    add:\n      - NET_ADMIN\n    drop: []\n  readOnlyRootFilesystem: false\n</code></pre> <p>Install the controller:</p> <pre><code>helm install cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --values awg-values.yaml\n</code></pre>"},{"location":"guides/awg-sidecar/#step-4-create-gateway-and-httproute","title":"Step 4: Create Gateway and HTTPRoute","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: cloudflare-tunnel\n  namespace: cloudflare-tunnel-system\nspec:\n  gatewayClassName: cloudflare-tunnel\n  listeners:\n    - name: https\n      port: 443\n      protocol: HTTPS\n      allowedRoutes:\n        namespaces:\n          from: All\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: my-app\n  namespace: default\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - backendRefs:\n        - name: my-service\n          port: 80\n</code></pre>"},{"location":"guides/awg-sidecar/#security-considerations","title":"Security Considerations","text":"<p>AWG sidecar requires elevated privileges:</p> Setting Value Reason <code>runAsUser</code> <code>0</code> Root required for network interface creation <code>NET_ADMIN</code> Required WireGuard interface management <code>allowPrivilegeEscalation</code> <code>true</code> Capability elevation <p>Scope of Elevated Privileges</p> <p>These permissions are only needed for the cloudflared pod with AWG sidecar, not for the controller itself.</p>"},{"location":"guides/awg-sidecar/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/awg-sidecar/#awg-interface-not-created","title":"AWG interface not created","text":"<p>Check that NET_ADMIN capability is granted:</p> <pre><code>kubectl get pod --namespace cloudflare-tunnel-system \\\n  --selector app=cloudflared --output yaml | grep -A5 capabilities\n</code></pre>"},{"location":"guides/awg-sidecar/#tunnel-not-connecting","title":"Tunnel not connecting","text":"<p>Verify AllowedIPs includes all Cloudflare IP ranges:</p> <pre><code>kubectl get secret awg-config --namespace cloudflare-tunnel-system \\\n  --output jsonpath='{.data.wg0\\.conf}' | base64 -d | grep AllowedIPs\n</code></pre> <p>Compare with current Cloudflare ranges: https://www.cloudflare.com/ips/</p>"},{"location":"guides/awg-sidecar/#dns-not-resolving-inside-pod","title":"DNS not resolving inside pod","text":"<p>AWG sidecar preserves cluster DNS configuration. Verify DNS is working:</p> <pre><code>kubectl exec --namespace cloudflare-tunnel-system \\\n  deploy/cloudflared -- nslookup kubernetes.default.svc.cluster.local\n</code></pre>"},{"location":"guides/awg-sidecar/#check-awg-sidecar-logs","title":"Check AWG sidecar logs","text":"<pre><code>kubectl logs --namespace cloudflare-tunnel-system \\\n  deploy/cloudflared --container awg-sidecar\n</code></pre>"},{"location":"guides/awg-sidecar/#check-cloudflared-logs","title":"Check cloudflared logs","text":"<pre><code>kubectl logs --namespace cloudflare-tunnel-system \\\n  deploy/cloudflared --container cloudflared\n</code></pre>"},{"location":"guides/awg-sidecar/#architecture","title":"Architecture","text":"<pre><code>flowchart LR\n    subgraph Pod[\"cloudflared Pod\"]\n        CFD[cloudflared]\n        AWG[AWG Sidecar]\n    end\n\n    subgraph Network\n        WG[AWG Server]\n        CF[Cloudflare Edge]\n    end\n\n    CFD --&gt;|traffic| AWG\n    AWG --&gt;|obfuscated| WG\n    WG --&gt;|decrypted| CF</code></pre> <p>Traffic flow:</p> <ol> <li>cloudflared sends traffic to AWG sidecar</li> <li>AWG sidecar encrypts and obfuscates traffic</li> <li>Traffic is sent to AWG server</li> <li>AWG server decrypts and forwards to Cloudflare</li> </ol>"},{"location":"guides/cross-namespace/","title":"Cross-Namespace Routing","text":"<p>This guide covers routing traffic to services in different namespaces using ReferenceGrant.</p>"},{"location":"guides/cross-namespace/#overview","title":"Overview","text":"<p>By default, Gateway API only allows Routes to reference Services in the same namespace. Cross-namespace references require explicit permission via ReferenceGrant.</p>"},{"location":"guides/cross-namespace/#use-cases","title":"Use Cases","text":"<ul> <li>Shared services: Route to services in a <code>shared-services</code> namespace</li> <li>Multi-team deployments: Teams own namespaces but share ingress</li> <li>Service mesh patterns: Central gateway routing to distributed services</li> </ul>"},{"location":"guides/cross-namespace/#basic-setup","title":"Basic Setup","text":""},{"location":"guides/cross-namespace/#1-create-referencegrant-in-target-namespace","title":"1. Create ReferenceGrant in Target Namespace","text":"<p>The ReferenceGrant must be created in the namespace where the Service exists:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-frontend-routes\n  namespace: backend  # Where the Service is\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: frontend  # Where the Route is\n  to:\n    - group: \"\"  # Core API group\n      kind: Service\n</code></pre>"},{"location":"guides/cross-namespace/#2-create-httproute-with-cross-namespace-reference","title":"2. Create HTTPRoute with Cross-Namespace Reference","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: api-route\n  namespace: frontend  # Source namespace\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - api.example.com\n  rules:\n    - backendRefs:\n        - name: api-service\n          namespace: backend  # Target namespace\n          port: 8080\n</code></pre>"},{"location":"guides/cross-namespace/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/cross-namespace/#shared-services-namespace","title":"Shared Services Namespace","text":"<p>Allow all namespaces to route to shared services:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-all-to-shared\n  namespace: shared-services\nspec:\n  from:\n    # Allow from app namespaces\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: app-team-a\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: app-team-b\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: app-team-c\n  to:\n    - group: \"\"\n      kind: Service\n</code></pre>"},{"location":"guides/cross-namespace/#specific-service-access","title":"Specific Service Access","text":"<p>Restrict access to specific services:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-public-api-only\n  namespace: backend\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: frontend\n  to:\n    - group: \"\"\n      kind: Service\n      name: public-api  # Only this service\n</code></pre>"},{"location":"guides/cross-namespace/#grpcroute-cross-namespace","title":"GRPCRoute Cross-Namespace","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-grpc-routes\n  namespace: grpc-services\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: GRPCRoute\n      namespace: grpc-clients\n  to:\n    - group: \"\"\n      kind: Service\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: user-service\n  namespace: grpc-clients\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - grpc.example.com\n  rules:\n    - matches:\n        - method:\n            service: mypackage.UserService\n      backendRefs:\n        - name: user-grpc\n          namespace: grpc-services\n          port: 50051\n</code></pre>"},{"location":"guides/cross-namespace/#multi-service-routing","title":"Multi-Service Routing","text":"<p>Route to multiple services in different namespaces:</p> <pre><code>---\n# ReferenceGrant for team-a services\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-gateway-routes\n  namespace: team-a\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: ingress\n  to:\n    - group: \"\"\n      kind: Service\n---\n# ReferenceGrant for team-b services\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-gateway-routes\n  namespace: team-b\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: ingress\n  to:\n    - group: \"\"\n      kind: Service\n---\n# Single HTTPRoute routing to multiple namespaces\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: multi-team-route\n  namespace: ingress\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /team-a\n      backendRefs:\n        - name: team-a-service\n          namespace: team-a\n          port: 8080\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /team-b\n      backendRefs:\n        - name: team-b-service\n          namespace: team-b\n          port: 8080\n</code></pre>"},{"location":"guides/cross-namespace/#verification","title":"Verification","text":""},{"location":"guides/cross-namespace/#check-referencegrant-status","title":"Check ReferenceGrant Status","text":"<pre><code>kubectl get referencegrant --all-namespaces\n</code></pre>"},{"location":"guides/cross-namespace/#check-route-status","title":"Check Route Status","text":"<pre><code>kubectl get httproute api-route --namespace frontend \\\n  --output jsonpath='{.status.parents[*].conditions}'\n</code></pre> <p>Look for <code>ResolvedRefs: True</code>. If <code>False</code> with reason <code>RefNotPermitted</code>, the ReferenceGrant is missing or misconfigured.</p>"},{"location":"guides/cross-namespace/#debug-missing-grants","title":"Debug Missing Grants","text":"<pre><code># Check controller logs for reference errors\nkubectl logs --selector app.kubernetes.io/name=cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system | grep -i reference\n</code></pre>"},{"location":"guides/cross-namespace/#security-considerations","title":"Security Considerations","text":"<p>Principle of Least Privilege</p> <ul> <li>Create ReferenceGrants with minimum necessary permissions</li> <li>Use <code>to[].name</code> to restrict to specific Services when possible</li> <li>Regularly audit ReferenceGrants in shared namespaces</li> <li>Consider namespace isolation for sensitive services</li> </ul>"},{"location":"guides/cross-namespace/#audit-script","title":"Audit Script","text":"<pre><code>#!/bin/bash\n# List all cross-namespace permissions\nfor ns in $(kubectl get ns -o jsonpath='{.items[*].metadata.name}'); do\n  grants=$(kubectl get referencegrant -n \"$ns\" -o name 2&gt;/dev/null)\n  if [ -n \"$grants\" ]; then\n    echo \"Namespace: $ns\"\n    kubectl get referencegrant -n \"$ns\" -o yaml | grep -A5 'from:'\n    echo \"---\"\n  fi\ndone\n</code></pre>"},{"location":"guides/cross-namespace/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/cross-namespace/#refnotpermitted-error","title":"RefNotPermitted Error","text":"<ol> <li>Verify ReferenceGrant is in the target namespace (where Service is)</li> <li>Check <code>from[].namespace</code> matches the Route's namespace</li> <li>Check <code>from[].kind</code> is correct (HTTPRoute or GRPCRoute)</li> <li>Check <code>from[].group</code> is <code>gateway.networking.k8s.io</code></li> <li>Check <code>to[].group</code> is <code>\"\"</code> (empty string for Services)</li> </ol>"},{"location":"guides/cross-namespace/#service-not-found","title":"Service Not Found","text":"<p>Even with ReferenceGrant, the target Service must exist:</p> <pre><code>kubectl get service api-service --namespace backend\n</code></pre>"},{"location":"guides/cross-namespace/#network-policy-blocking-traffic","title":"Network Policy Blocking Traffic","text":"<p>If using NetworkPolicy, ensure traffic is allowed between namespaces:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-from-cloudflared\n  namespace: backend\nspec:\n  podSelector: {}\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              kubernetes.io/metadata.name: cloudflare-tunnel-system\n</code></pre>"},{"location":"guides/external-dns/","title":"External-DNS Integration","text":"<p>This guide covers integrating the Cloudflare Tunnel Gateway Controller with external-dns for automatic DNS record management.</p>"},{"location":"guides/external-dns/#overview","title":"Overview","text":"<p>The controller sets <code>status.addresses</code> on the Gateway with the tunnel CNAME (<code>TUNNEL_ID.cfargotunnel.com</code>). When external-dns is configured with Gateway API source, it automatically creates DNS records for your HTTPRoute hostnames.</p>"},{"location":"guides/external-dns/#prerequisites","title":"Prerequisites","text":"<ul> <li>Cloudflare Tunnel Gateway Controller installed</li> <li>external-dns installed and configured for Cloudflare</li> <li>Cloudflare API token with DNS edit permissions</li> </ul>"},{"location":"guides/external-dns/#external-dns-configuration","title":"external-dns Configuration","text":""},{"location":"guides/external-dns/#helm-values","title":"Helm Values","text":"<pre><code># external-dns values.yaml\nprovider:\n  name: cloudflare\n\nenv:\n  - name: CF_API_TOKEN\n    valueFrom:\n      secretKeyRef:\n        name: cloudflare-dns-token\n        key: api-token\n\nsources:\n  - gateway-httproute\n  - gateway-grpcroute\n\nextraArgs:\n  - --gateway-namespace=cloudflare-tunnel-system\n  - --gateway-label-filter=app.kubernetes.io/name=cloudflare-tunnel-gateway-controller\n</code></pre>"},{"location":"guides/external-dns/#api-token-permissions","title":"API Token Permissions","text":"<p>The external-dns API token needs:</p> Scope Permission Access Zone DNS Edit Zone Zone Read <p>Separate Tokens</p> <p>Use separate API tokens for the tunnel controller (Tunnel Edit) and external-dns (DNS Edit) following the principle of least privilege.</p>"},{"location":"guides/external-dns/#httproute-annotations","title":"HTTPRoute Annotations","text":"<p>Add annotations to HTTPRoute for DNS configuration:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: my-app\n  annotations:\n    # Enable Cloudflare proxy (orange cloud)\n    external-dns.alpha.kubernetes.io/cloudflare-proxied: \"true\"\n    # Custom TTL (seconds)\n    external-dns.alpha.kubernetes.io/ttl: \"300\"\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - backendRefs:\n        - name: my-service\n          port: 80\n</code></pre>"},{"location":"guides/external-dns/#common-annotations","title":"Common Annotations","text":"Annotation Description Example <code>external-dns.alpha.kubernetes.io/cloudflare-proxied</code> Enable Cloudflare proxy <code>\"true\"</code> <code>external-dns.alpha.kubernetes.io/ttl</code> DNS record TTL <code>\"300\"</code> <code>external-dns.alpha.kubernetes.io/target</code> Override CNAME target <code>custom.example.com</code> <code>external-dns.alpha.kubernetes.io/hostname</code> Override hostname <code>override.example.com</code>"},{"location":"guides/external-dns/#how-it-works","title":"How It Works","text":"<pre><code>sequenceDiagram\n    participant User\n    participant K8s as Kubernetes\n    participant Ctrl as Controller\n    participant ExtDNS as external-dns\n    participant CF as Cloudflare\n\n    User-&gt;&gt;K8s: Create HTTPRoute\n    K8s-&gt;&gt;Ctrl: Watch event\n    Ctrl-&gt;&gt;CF: Update tunnel config\n    Ctrl-&gt;&gt;K8s: Update Gateway status.addresses\n    K8s-&gt;&gt;ExtDNS: Watch Gateway/HTTPRoute\n    ExtDNS-&gt;&gt;CF: Create DNS CNAME record\n    Note over CF: app.example.com \u2192 TUNNEL_ID.cfargotunnel.com</code></pre> <ol> <li>User creates HTTPRoute with hostnames</li> <li>Controller updates tunnel configuration in Cloudflare</li> <li>Controller sets Gateway <code>status.addresses</code> to tunnel CNAME</li> <li>external-dns watches Gateway and HTTPRoute</li> <li>external-dns creates CNAME record pointing to tunnel</li> </ol>"},{"location":"guides/external-dns/#verifying-dns-records","title":"Verifying DNS Records","text":"<p>Check that external-dns created the record:</p> <pre><code># Check external-dns logs\nkubectl logs --selector app.kubernetes.io/name=external-dns\n\n# Query DNS\ndig app.example.com CNAME\n\n# Expected output\n# app.example.com. 300 IN CNAME abc123.cfargotunnel.com.\n</code></pre>"},{"location":"guides/external-dns/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/external-dns/#dns-record-not-created","title":"DNS Record Not Created","text":"<ol> <li>Check external-dns logs for errors:</li> </ol> <pre><code>kubectl logs --selector app.kubernetes.io/name=external-dns | grep -i error\n</code></pre> <ol> <li>Verify Gateway has address set:</li> </ol> <pre><code>kubectl get gateway cloudflare-tunnel --namespace cloudflare-tunnel-system \\\n  --output jsonpath='{.status.addresses[*].value}'\n</code></pre> <ol> <li>Verify HTTPRoute is accepted:</li> </ol> <pre><code>kubectl get httproute my-app --output jsonpath='{.status.parents[*].conditions}'\n</code></pre>"},{"location":"guides/external-dns/#proxy-status-not-applied","title":"Proxy Status Not Applied","text":"<p>Ensure the annotation is on the HTTPRoute, not the Gateway:</p> <pre><code># Correct - annotation on HTTPRoute\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  annotations:\n    external-dns.alpha.kubernetes.io/cloudflare-proxied: \"true\"\n</code></pre>"},{"location":"guides/external-dns/#multiple-gateways","title":"Multiple Gateways","text":"<p>If you have multiple Gateways, use label filters:</p> <pre><code>extraArgs:\n  - --gateway-label-filter=app.kubernetes.io/instance=my-tunnel\n</code></pre>"},{"location":"guides/external-dns/#production-recommendations","title":"Production Recommendations","text":"<ol> <li> <p>Use Cloudflare Proxy - Always set <code>cloudflare-proxied: \"true\"</code> for    DDoS protection and caching</p> </li> <li> <p>TTL Settings - When using Cloudflare proxy, TTL is managed by    Cloudflare (set to \"Auto\")</p> </li> <li> <p>Separate Zones - Consider separate DNS zones for different    environments (prod, staging)</p> </li> <li> <p>Policy Mode - Use <code>--policy=sync</code> in production for external-dns    to clean up stale records</p> </li> </ol>"},{"location":"guides/external-dns/#example-complete-setup","title":"Example: Complete Setup","text":"<pre><code>---\n# external-dns deployment\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: external-dns\n  namespace: external-dns\nspec:\n  selector:\n    matchLabels:\n      app: external-dns\n  template:\n    metadata:\n      labels:\n        app: external-dns\n    spec:\n      containers:\n        - name: external-dns\n          image: registry.k8s.io/external-dns/external-dns:v0.14.0\n          args:\n            - --source=gateway-httproute\n            - --source=gateway-grpcroute\n            - --provider=cloudflare\n            - --cloudflare-proxied\n            - --policy=sync\n            - --gateway-namespace=cloudflare-tunnel-system\n          env:\n            - name: CF_API_TOKEN\n              valueFrom:\n                secretKeyRef:\n                  name: cloudflare-dns-token\n                  key: api-token\n---\n# HTTPRoute with DNS annotations\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: my-app\n  annotations:\n    external-dns.alpha.kubernetes.io/cloudflare-proxied: \"true\"\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n    - www.example.com\n  rules:\n    - backendRefs:\n        - name: my-service\n          port: 80\n</code></pre>"},{"location":"guides/monitoring/","title":"Monitoring","text":"<p>This guide covers setting up monitoring for the Cloudflare Tunnel Gateway Controller using Prometheus and Grafana.</p>"},{"location":"guides/monitoring/#overview","title":"Overview","text":"<p>The controller exposes Prometheus metrics for monitoring reconciliation performance, errors, and resource usage.</p>"},{"location":"guides/monitoring/#endpoints","title":"Endpoints","text":"Endpoint Port Description <code>/metrics</code> 8080 Prometheus metrics <code>/healthz</code> 8081 Liveness probe <code>/readyz</code> 8081 Readiness probe"},{"location":"guides/monitoring/#quick-setup-with-helm","title":"Quick Setup with Helm","text":"<p>Enable ServiceMonitor in Helm values:</p> <pre><code>serviceMonitor:\n  enabled: true\n  interval: 30s\n  labels:\n    release: prometheus  # Match your Prometheus selector\n</code></pre>"},{"location":"guides/monitoring/#manual-servicemonitor","title":"Manual ServiceMonitor","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: cloudflare-tunnel-gateway-controller\n  namespace: cloudflare-tunnel-system\n  labels:\n    app.kubernetes.io/name: cloudflare-tunnel-gateway-controller\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: cloudflare-tunnel-gateway-controller\n  endpoints:\n    - port: metrics\n      interval: 30s\n      path: /metrics\n</code></pre>"},{"location":"guides/monitoring/#available-metrics","title":"Available Metrics","text":""},{"location":"guides/monitoring/#controller-metrics","title":"Controller Metrics","text":"Metric Type Description <code>controller_runtime_reconcile_total</code> Counter Total reconciliations per controller <code>controller_runtime_reconcile_errors_total</code> Counter Total reconciliation errors <code>controller_runtime_reconcile_time_seconds</code> Histogram Reconciliation duration <code>controller_runtime_max_concurrent_reconciles</code> Gauge Max concurrent reconciles <code>controller_runtime_active_workers</code> Gauge Current active workers"},{"location":"guides/monitoring/#workqueue-metrics","title":"Workqueue Metrics","text":"Metric Type Description <code>workqueue_adds_total</code> Counter Items added to queue <code>workqueue_depth</code> Gauge Current queue depth <code>workqueue_queue_duration_seconds</code> Histogram Time in queue <code>workqueue_work_duration_seconds</code> Histogram Processing time <code>workqueue_retries_total</code> Counter Item retries"},{"location":"guides/monitoring/#go-runtime-metrics","title":"Go Runtime Metrics","text":"Metric Type Description <code>go_goroutines</code> Gauge Number of goroutines <code>go_gc_duration_seconds</code> Summary GC pause duration <code>go_memstats_alloc_bytes</code> Gauge Allocated memory <code>process_cpu_seconds_total</code> Counter CPU time used <code>process_resident_memory_bytes</code> Gauge Resident memory"},{"location":"guides/monitoring/#useful-promql-queries","title":"Useful PromQL Queries","text":""},{"location":"guides/monitoring/#reconciliation-rate","title":"Reconciliation Rate","text":"<pre><code># Reconciliations per second by controller\nsum(rate(controller_runtime_reconcile_total[5m])) by (controller)\n\n# Error rate\nsum(rate(controller_runtime_reconcile_errors_total[5m])) by (controller)\n\n# Error percentage\nsum(rate(controller_runtime_reconcile_errors_total[5m])) by (controller)\n/\nsum(rate(controller_runtime_reconcile_total[5m])) by (controller)\n* 100\n</code></pre>"},{"location":"guides/monitoring/#reconciliation-latency","title":"Reconciliation Latency","text":"<pre><code># P50 latency\nhistogram_quantile(0.50,\n  sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n)\n\n# P95 latency\nhistogram_quantile(0.95,\n  sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n)\n\n# P99 latency\nhistogram_quantile(0.99,\n  sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n)\n</code></pre>"},{"location":"guides/monitoring/#queue-health","title":"Queue Health","text":"<pre><code># Queue depth (should be low)\nworkqueue_depth{name=~\".*gateway.*|.*httproute.*\"}\n\n# Average time in queue\nsum(workqueue_queue_duration_seconds_sum) by (name)\n/\nsum(workqueue_queue_duration_seconds_count) by (name)\n</code></pre>"},{"location":"guides/monitoring/#resource-usage","title":"Resource Usage","text":"<pre><code># Memory usage\nprocess_resident_memory_bytes{job=\"cloudflare-tunnel-gateway-controller\"}\n\n# CPU usage\nrate(process_cpu_seconds_total{job=\"cloudflare-tunnel-gateway-controller\"}[5m])\n\n# Goroutines\ngo_goroutines{job=\"cloudflare-tunnel-gateway-controller\"}\n</code></pre>"},{"location":"guides/monitoring/#alerting-rules","title":"Alerting Rules","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: PrometheusRule\nmetadata:\n  name: cloudflare-tunnel-gateway-controller\n  namespace: cloudflare-tunnel-system\nspec:\n  groups:\n    - name: cloudflare-tunnel-gateway-controller\n      rules:\n        # High error rate\n        - alert: CloudflareTunnelControllerHighErrorRate\n          expr: |\n            sum(rate(controller_runtime_reconcile_errors_total[5m])) by (controller)\n            /\n            sum(rate(controller_runtime_reconcile_total[5m])) by (controller)\n            &gt; 0.1\n          for: 5m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"High reconciliation error rate\"\n            description: \"Controller {{ $labels.controller }} has error rate {{ $value | humanizePercentage }}\"\n\n        # Slow reconciliation\n        - alert: CloudflareTunnelControllerSlowReconciliation\n          expr: |\n            histogram_quantile(0.99,\n              sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n            ) &gt; 30\n          for: 10m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"Slow reconciliation\"\n            description: \"Controller {{ $labels.controller }} P99 latency is {{ $value | humanizeDuration }}\"\n\n        # Queue backlog\n        - alert: CloudflareTunnelControllerQueueBacklog\n          expr: workqueue_depth{name=~\".*gateway.*|.*httproute.*\"} &gt; 100\n          for: 5m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"Workqueue backlog\"\n            description: \"Queue {{ $labels.name }} has {{ $value }} items pending\"\n\n        # Controller down\n        - alert: CloudflareTunnelControllerDown\n          expr: up{job=\"cloudflare-tunnel-gateway-controller\"} == 0\n          for: 2m\n          labels:\n            severity: critical\n          annotations:\n            summary: \"Controller is down\"\n            description: \"Cloudflare Tunnel Gateway Controller is not responding\"\n\n        # High memory\n        - alert: CloudflareTunnelControllerHighMemory\n          expr: |\n            process_resident_memory_bytes{job=\"cloudflare-tunnel-gateway-controller\"}\n            &gt; 512 * 1024 * 1024\n          for: 10m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"High memory usage\"\n            description: \"Controller using {{ $value | humanize1024 }}B memory\"\n</code></pre>"},{"location":"guides/monitoring/#grafana-dashboard","title":"Grafana Dashboard","text":"<p>Import this dashboard or use as reference:</p> <pre><code>{\n  \"title\": \"Cloudflare Tunnel Gateway Controller\",\n  \"panels\": [\n    {\n      \"title\": \"Reconciliations/sec\",\n      \"type\": \"timeseries\",\n      \"targets\": [\n        {\n          \"expr\": \"sum(rate(controller_runtime_reconcile_total[5m])) by (controller)\",\n          \"legendFormat\": \"{{ controller }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Error Rate %\",\n      \"type\": \"timeseries\",\n      \"targets\": [\n        {\n          \"expr\": \"sum(rate(controller_runtime_reconcile_errors_total[5m])) by (controller) / sum(rate(controller_runtime_reconcile_total[5m])) by (controller) * 100\",\n          \"legendFormat\": \"{{ controller }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Reconciliation Latency\",\n      \"type\": \"timeseries\",\n      \"targets\": [\n        {\n          \"expr\": \"histogram_quantile(0.50, sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller))\",\n          \"legendFormat\": \"p50 {{ controller }}\"\n        },\n        {\n          \"expr\": \"histogram_quantile(0.95, sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller))\",\n          \"legendFormat\": \"p95 {{ controller }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Queue Depth\",\n      \"type\": \"timeseries\",\n      \"targets\": [\n        {\n          \"expr\": \"workqueue_depth\",\n          \"legendFormat\": \"{{ name }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Memory Usage\",\n      \"type\": \"stat\",\n      \"targets\": [\n        {\n          \"expr\": \"process_resident_memory_bytes{job=\\\"cloudflare-tunnel-gateway-controller\\\"}\"\n        }\n      ],\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"unit\": \"bytes\"\n        }\n      }\n    },\n    {\n      \"title\": \"Goroutines\",\n      \"type\": \"stat\",\n      \"targets\": [\n        {\n          \"expr\": \"go_goroutines{job=\\\"cloudflare-tunnel-gateway-controller\\\"}\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/monitoring/#health-checks","title":"Health Checks","text":""},{"location":"guides/monitoring/#liveness-probe","title":"Liveness Probe","text":"<pre><code>curl http://localhost:8081/healthz\n# Returns: ok\n</code></pre>"},{"location":"guides/monitoring/#readiness-probe","title":"Readiness Probe","text":"<pre><code>curl http://localhost:8081/readyz\n# Returns: ok\n</code></pre>"},{"location":"guides/monitoring/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/monitoring/#no-metrics-available","title":"No Metrics Available","text":"<ol> <li>Check controller is running:</li> </ol> <pre><code>kubectl get pods --namespace cloudflare-tunnel-system\n</code></pre> <ol> <li>Check metrics endpoint:</li> </ol> <pre><code>kubectl port-forward --namespace cloudflare-tunnel-system \\\n  svc/cloudflare-tunnel-gateway-controller 8080:8080\ncurl http://localhost:8080/metrics\n</code></pre>"},{"location":"guides/monitoring/#servicemonitor-not-working","title":"ServiceMonitor Not Working","text":"<ol> <li>Check Prometheus is discovering the ServiceMonitor:</li> </ol> <pre><code>kubectl get servicemonitor --all-namespaces\n</code></pre> <ol> <li> <p>Check Prometheus targets in UI at <code>/targets</code></p> </li> <li> <p>Verify labels match Prometheus selector</p> </li> </ol>"},{"location":"operations/","title":"Operations","text":"<p>This section covers operational aspects of running the Cloudflare Tunnel Gateway Controller in production.</p>"},{"location":"operations/#overview","title":"Overview","text":"<p>Operating the controller effectively requires understanding:</p> <ul> <li>Common issues and how to troubleshoot them</li> <li>Metrics and alerting for proactive monitoring</li> <li>Alternative installation methods for special environments</li> </ul>"},{"location":"operations/#sections","title":"Sections","text":"<ul> <li> <p> Troubleshooting</p> <p>Common issues, debugging techniques, and solutions.</p> <p> Troubleshooting</p> </li> <li> <p> Metrics &amp; Alerting</p> <p>Prometheus metrics reference and alerting rules.</p> <p> Metrics &amp; Alerting</p> </li> <li> <p> Manual Installation</p> <p>Installation without Helm for special requirements.</p> <p> Manual Installation</p> </li> </ul>"},{"location":"operations/#quick-diagnostics","title":"Quick Diagnostics","text":"<p>Check controller health:</p> <pre><code># Controller logs\nkubectl logs --selector app.kubernetes.io/name=cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system\n\n# Gateway status\nkubectl get gateway cloudflare-tunnel --namespace cloudflare-tunnel-system \\\n  --output jsonpath='{.status.conditions}'\n\n# HTTPRoute status\nkubectl get httproute --all-namespaces \\\n  --output custom-columns='NAMESPACE:.metadata.namespace,NAME:.metadata.name,ACCEPTED:.status.parents[*].conditions[?(@.type==\"Accepted\")].status'\n</code></pre>"},{"location":"operations/#production-checklist","title":"Production Checklist","text":"<ul> <li> Leader election enabled for HA deployments</li> <li> Resource limits configured</li> <li> Prometheus ServiceMonitor deployed</li> <li> Alerting rules configured</li> <li> Log aggregation set up</li> <li> Backup strategy for GatewayClassConfig secrets</li> </ul>"},{"location":"operations/manual-installation/","title":"Manual Installation","text":"<p>Not Recommended</p> <p>The recommended installation method is via Helm chart. Use manual installation only if you have specific requirements that prevent using Helm.</p>"},{"location":"operations/manual-installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with kubectl configured</li> <li>Gateway API CRDs installed</li> <li>Cloudflare account with a pre-created tunnel</li> </ul>"},{"location":"operations/manual-installation/#installation-steps","title":"Installation Steps","text":""},{"location":"operations/manual-installation/#1-install-gateway-api-crds","title":"1. Install Gateway API CRDs","text":"<pre><code>kubectl apply --filename https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.4.0/standard-install.yaml\n</code></pre>"},{"location":"operations/manual-installation/#2-create-namespace","title":"2. Create Namespace","text":"<pre><code>kubectl create namespace cloudflare-tunnel-system\n</code></pre>"},{"location":"operations/manual-installation/#3-create-secrets","title":"3. Create Secrets","text":"<pre><code># Cloudflare API credentials\nkubectl create secret generic cloudflare-credentials \\\n  --namespace cloudflare-tunnel-system \\\n  --from-literal=api-token=\"YOUR_API_TOKEN\"\n\n# Tunnel token (required for managed cloudflared)\nkubectl create secret generic cloudflare-tunnel-token \\\n  --namespace cloudflare-tunnel-system \\\n  --from-literal=tunnel-token=\"YOUR_TUNNEL_TOKEN\"\n</code></pre>"},{"location":"operations/manual-installation/#4-deploy-the-controller","title":"4. Deploy the Controller","text":"<pre><code>kubectl apply --filename deploy/rbac/\nkubectl apply --filename deploy/controller/\n</code></pre>"},{"location":"operations/manual-installation/#5-create-gatewayclassconfig-gatewayclass-and-gateway","title":"5. Create GatewayClassConfig, GatewayClass, and Gateway","text":"<p>Edit <code>deploy/samples/gatewayclassconfig.yaml</code> with your tunnel ID:</p> <pre><code>kubectl apply --filename deploy/samples/gatewayclassconfig.yaml\nkubectl apply --filename deploy/samples/gatewayclass.yaml\nkubectl apply --filename deploy/samples/gateway.yaml\n</code></pre>"},{"location":"operations/manual-installation/#manifest-structure","title":"Manifest Structure","text":"<p>The <code>deploy/</code> directory contains:</p> <pre><code>deploy/\n\u251c\u2500\u2500 rbac/\n\u2502   \u251c\u2500\u2500 serviceaccount.yaml\n\u2502   \u251c\u2500\u2500 clusterrole.yaml\n\u2502   \u2514\u2500\u2500 clusterrolebinding.yaml\n\u251c\u2500\u2500 controller/\n\u2502   \u2514\u2500\u2500 deployment.yaml\n\u2514\u2500\u2500 samples/\n    \u251c\u2500\u2500 secrets.yaml\n    \u251c\u2500\u2500 gatewayclassconfig.yaml\n    \u251c\u2500\u2500 gatewayclass.yaml\n    \u2514\u2500\u2500 gateway.yaml\n</code></pre>"},{"location":"operations/manual-installation/#sample-gatewayclassconfig","title":"Sample GatewayClassConfig","text":"<pre><code>apiVersion: cf.k8s.lex.la/v1alpha1\nkind: GatewayClassConfig\nmetadata:\n  name: cloudflare-tunnel-config\nspec:\n  tunnelID: \"YOUR_TUNNEL_UUID\"\n  cloudflareCredentialsSecretRef:\n    name: cloudflare-credentials\n  tunnelTokenSecretRef:\n    name: cloudflare-tunnel-token\n  cloudflared:\n    enabled: true\n</code></pre>"},{"location":"operations/manual-installation/#sample-gatewayclass","title":"Sample GatewayClass","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: cloudflare-tunnel\nspec:\n  controllerName: cf.k8s.lex.la/tunnel-controller\n  parametersRef:\n    group: cf.k8s.lex.la\n    kind: GatewayClassConfig\n    name: cloudflare-tunnel-config\n</code></pre>"},{"location":"operations/manual-installation/#sample-gateway","title":"Sample Gateway","text":"<pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: cloudflare-tunnel\n  namespace: cloudflare-tunnel-system\nspec:\n  gatewayClassName: cloudflare-tunnel\n  listeners:\n    - name: http\n      port: 80\n      protocol: HTTP\n</code></pre>"},{"location":"operations/manual-installation/#upgrading","title":"Upgrading","text":"<p>When upgrading manually, apply manifests in order:</p> <ol> <li>Update CRDs (if changed)</li> <li>Update RBAC resources</li> <li>Update controller deployment</li> </ol> <pre><code>kubectl apply --filename deploy/rbac/\nkubectl apply --filename deploy/controller/\n</code></pre>"},{"location":"operations/manual-installation/#uninstalling","title":"Uninstalling","text":"<pre><code>kubectl delete --filename deploy/samples/gateway.yaml\nkubectl delete --filename deploy/samples/gatewayclass.yaml\nkubectl delete --filename deploy/samples/gatewayclassconfig.yaml\nkubectl delete --filename deploy/controller/\nkubectl delete --filename deploy/rbac/\nkubectl delete namespace cloudflare-tunnel-system\n</code></pre>"},{"location":"operations/manual-installation/#comparison-with-helm","title":"Comparison with Helm","text":"Aspect Helm Manual CRD management Automatic Manual RBAC setup Automatic Manual Upgrades <code>helm upgrade</code> <code>kubectl apply</code> Rollback <code>helm rollback</code> Manual Value validation Schema validation None Templating Built-in None"},{"location":"operations/manual-installation/#when-to-use-manual-installation","title":"When to Use Manual Installation","text":"<ul> <li>Air-gapped environments without Helm access</li> <li>Strict policy requirements against Helm</li> <li>Custom modifications not supported by chart</li> <li>Educational/debugging purposes</li> </ul> <p>For production deployments, the Helm chart is strongly recommended for its ease of use, upgrade path, and validation features.</p>"},{"location":"operations/metrics/","title":"Metrics &amp; Alerting","text":"<p>The controller exposes Prometheus metrics for monitoring and alerting.</p>"},{"location":"operations/metrics/#endpoints","title":"Endpoints","text":"Endpoint Port Description <code>/metrics</code> 8080 Prometheus metrics <code>/healthz</code> 8081 Liveness probe <code>/readyz</code> 8081 Readiness probe"},{"location":"operations/metrics/#available-metrics","title":"Available Metrics","text":""},{"location":"operations/metrics/#route-synchronization-metrics","title":"Route Synchronization Metrics","text":"<p>These metrics track the core synchronization of routes to Cloudflare Tunnel.</p> Metric Type Labels Description <code>cftunnel_sync_duration_seconds</code> Histogram <code>status</code> Duration of route sync operations <code>cftunnel_synced_routes</code> Gauge <code>type</code> Number of routes synced (http/grpc) <code>cftunnel_ingress_rules</code> Gauge - Total ingress rules in tunnel config <code>cftunnel_failed_backend_refs</code> Gauge <code>type</code> Failed backend references by route type <code>cftunnel_sync_errors_total</code> Counter <code>error_type</code> Sync errors by type"},{"location":"operations/metrics/#cloudflare-api-metrics","title":"Cloudflare API Metrics","text":"<p>Track Cloudflare API interactions for performance and reliability monitoring.</p> Metric Type Labels Description <code>cftunnel_cloudflare_api_duration_seconds</code> Histogram <code>method</code>, <code>resource</code> API call latency <code>cftunnel_cloudflare_api_calls_total</code> Counter <code>method</code>, <code>resource</code>, <code>status</code> API calls count <code>cftunnel_cloudflare_api_errors_total</code> Counter <code>method</code>, <code>error_type</code> API errors by type <p>Label values:</p> <ul> <li><code>method</code>: <code>get</code>, <code>list</code>, <code>update</code></li> <li><code>resource</code>: <code>tunnel_config</code>, <code>account</code></li> <li><code>status</code>: <code>success</code>, <code>error</code></li> <li><code>error_type</code>: <code>auth</code>, <code>rate_limit</code>, <code>timeout</code>, <code>server_error</code>, <code>network</code></li> </ul>"},{"location":"operations/metrics/#helm-operations-metrics","title":"Helm Operations Metrics","text":"<p>When cloudflared is managed by the controller via Helm.</p> Metric Type Labels Description <code>cftunnel_helm_operation_duration_seconds</code> Histogram <code>operation</code> Helm operation latency <code>cftunnel_helm_operations_total</code> Counter <code>operation</code>, <code>status</code> Helm operations count <code>cftunnel_helm_errors_total</code> Counter <code>operation</code>, <code>error_type</code> Helm errors <code>cftunnel_helm_chart_info</code> Gauge <code>chart</code>, <code>version</code>, <code>app_version</code> Deployed chart version info <p>Label values:</p> <ul> <li><code>operation</code>: <code>install</code>, <code>upgrade</code>, <code>uninstall</code>, <code>get_version</code>, <code>load_chart</code></li> <li><code>status</code>: <code>success</code>, <code>error</code></li> </ul>"},{"location":"operations/metrics/#ingress-builder-metrics","title":"Ingress Builder Metrics","text":"<p>Track the conversion of Gateway API routes to Cloudflare ingress rules.</p> Metric Type Labels Description <code>cftunnel_ingress_build_duration_seconds</code> Histogram <code>type</code> Rule building duration <code>cftunnel_backend_ref_validation_total</code> Counter <code>type</code>, <code>result</code>, <code>reason</code> Backend ref validation results"},{"location":"operations/metrics/#controller-runtime-metrics","title":"Controller Runtime Metrics","text":"<p>Built-in metrics from controller-runtime.</p> Metric Type Description <code>controller_runtime_reconcile_total</code> Counter Total reconciliations per controller <code>controller_runtime_reconcile_errors_total</code> Counter Total reconciliation errors <code>controller_runtime_reconcile_time_seconds</code> Histogram Reconciliation duration <code>controller_runtime_max_concurrent_reconciles</code> Gauge Max concurrent reconciles <code>controller_runtime_active_workers</code> Gauge Current active workers"},{"location":"operations/metrics/#workqueue-metrics","title":"Workqueue Metrics","text":"Metric Type Description <code>workqueue_adds_total</code> Counter Items added to queue <code>workqueue_depth</code> Gauge Current queue depth <code>workqueue_queue_duration_seconds</code> Histogram Time in queue <code>workqueue_work_duration_seconds</code> Histogram Processing time <code>workqueue_retries_total</code> Counter Item retries <code>workqueue_longest_running_processor_seconds</code> Gauge Longest running item"},{"location":"operations/metrics/#go-runtime-metrics","title":"Go Runtime Metrics","text":"Metric Type Description <code>go_goroutines</code> Gauge Number of goroutines <code>go_gc_duration_seconds</code> Summary GC pause duration <code>go_memstats_alloc_bytes</code> Gauge Allocated memory <code>go_memstats_heap_inuse_bytes</code> Gauge Heap in use"},{"location":"operations/metrics/#process-metrics","title":"Process Metrics","text":"Metric Type Description <code>process_cpu_seconds_total</code> Counter CPU time used <code>process_resident_memory_bytes</code> Gauge Resident memory <code>process_open_fds</code> Gauge Open file descriptors"},{"location":"operations/metrics/#prometheus-configuration","title":"Prometheus Configuration","text":""},{"location":"operations/metrics/#servicemonitor-prometheus-operator","title":"ServiceMonitor (Prometheus Operator)","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: cloudflare-tunnel-gateway-controller\n  namespace: cloudflare-tunnel-system\n  labels:\n    app.kubernetes.io/name: cloudflare-tunnel-gateway-controller\nspec:\n  selector:\n    matchLabels:\n      app.kubernetes.io/name: cloudflare-tunnel-gateway-controller\n  endpoints:\n    - port: metrics\n      interval: 30s\n      path: /metrics\n</code></pre>"},{"location":"operations/metrics/#scrape-config-prometheus","title":"Scrape Config (Prometheus)","text":"<pre><code>scrape_configs:\n  - job_name: cloudflare-tunnel-gateway-controller\n    kubernetes_sd_configs:\n      - role: endpoints\n        namespaces:\n          names:\n            - cloudflare-tunnel-system\n    relabel_configs:\n      - source_labels: [__meta_kubernetes_service_name]\n        action: keep\n        regex: cloudflare-tunnel-gateway-controller\n      - source_labels: [__meta_kubernetes_endpoint_port_name]\n        action: keep\n        regex: metrics\n</code></pre>"},{"location":"operations/metrics/#promql-queries","title":"PromQL Queries","text":""},{"location":"operations/metrics/#route-sync-performance","title":"Route Sync Performance","text":"<pre><code># Sync duration P95\nhistogram_quantile(0.95,\n  sum(rate(cftunnel_sync_duration_seconds_bucket[5m])) by (le)\n)\n\n# Sync error rate\nsum(rate(cftunnel_sync_errors_total[5m])) by (error_type)\n\n# Routes synced by type\nsum(cftunnel_synced_routes) by (type)\n\n# Total ingress rules\ncftunnel_ingress_rules\n\n# Failed backend references\nsum(cftunnel_failed_backend_refs) by (type)\n</code></pre>"},{"location":"operations/metrics/#cloudflare-api-health","title":"Cloudflare API Health","text":"<pre><code># API success rate\nsum(rate(cftunnel_cloudflare_api_calls_total{status=\"success\"}[5m]))\n/\nsum(rate(cftunnel_cloudflare_api_calls_total[5m]))\n\n# API latency P99\nhistogram_quantile(0.99,\n  sum(rate(cftunnel_cloudflare_api_duration_seconds_bucket[5m])) by (le, method)\n)\n\n# API errors by type\nsum(rate(cftunnel_cloudflare_api_errors_total[5m])) by (method, error_type)\n</code></pre>"},{"location":"operations/metrics/#helm-operations","title":"Helm Operations","text":"<pre><code># Helm operation success rate\nsum(rate(cftunnel_helm_operations_total{status=\"success\"}[5m])) by (operation)\n/\nsum(rate(cftunnel_helm_operations_total[5m])) by (operation)\n\n# Helm operation latency P95\nhistogram_quantile(0.95,\n  sum(rate(cftunnel_helm_operation_duration_seconds_bucket[5m])) by (le, operation)\n)\n</code></pre>"},{"location":"operations/metrics/#reconciliation-rate","title":"Reconciliation Rate","text":"<pre><code># Reconciliations per second by controller\nsum(rate(controller_runtime_reconcile_total[5m])) by (controller)\n\n# Error rate\nsum(rate(controller_runtime_reconcile_errors_total[5m])) by (controller)\n\n# Error percentage\nsum(rate(controller_runtime_reconcile_errors_total[5m])) by (controller)\n/\nsum(rate(controller_runtime_reconcile_total[5m])) by (controller)\n* 100\n</code></pre>"},{"location":"operations/metrics/#reconciliation-latency","title":"Reconciliation Latency","text":"<pre><code># P50 latency\nhistogram_quantile(0.50,\n  sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n)\n\n# P95 latency\nhistogram_quantile(0.95,\n  sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n)\n\n# P99 latency\nhistogram_quantile(0.99,\n  sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n)\n</code></pre>"},{"location":"operations/metrics/#queue-health","title":"Queue Health","text":"<pre><code># Queue depth (should be low)\nworkqueue_depth{name=~\".*gateway.*|.*httproute.*\"}\n\n# Average time in queue\nsum(workqueue_queue_duration_seconds_sum) by (name)\n/\nsum(workqueue_queue_duration_seconds_count) by (name)\n\n# Processing time\nsum(workqueue_work_duration_seconds_sum) by (name)\n/\nsum(workqueue_work_duration_seconds_count) by (name)\n</code></pre>"},{"location":"operations/metrics/#resource-usage","title":"Resource Usage","text":"<pre><code># Memory usage\nprocess_resident_memory_bytes{job=\"cloudflare-tunnel-gateway-controller\"}\n\n# CPU usage\nrate(process_cpu_seconds_total{job=\"cloudflare-tunnel-gateway-controller\"}[5m])\n\n# Goroutines\ngo_goroutines{job=\"cloudflare-tunnel-gateway-controller\"}\n</code></pre>"},{"location":"operations/metrics/#alerting-rules","title":"Alerting Rules","text":"<pre><code>apiVersion: monitoring.coreos.com/v1\nkind: PrometheusRule\nmetadata:\n  name: cloudflare-tunnel-gateway-controller\n  namespace: cloudflare-tunnel-system\nspec:\n  groups:\n    - name: cloudflare-tunnel-sync\n      rules:\n        - alert: CloudflareTunnelSyncErrors\n          expr: |\n            sum(rate(cftunnel_sync_errors_total[5m])) &gt; 0.1\n          for: 5m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"High sync error rate\"\n            description: \"Controller experiencing {{ $value | humanize }} sync errors/sec\"\n\n        - alert: CloudflareTunnelSyncSlow\n          expr: |\n            histogram_quantile(0.95,\n              sum(rate(cftunnel_sync_duration_seconds_bucket[5m])) by (le)\n            ) &gt; 10\n          for: 10m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"Slow route synchronization\"\n            description: \"P95 sync duration is {{ $value | humanizeDuration }}\"\n\n        - alert: CloudflareTunnelFailedBackendRefs\n          expr: |\n            sum(cftunnel_failed_backend_refs) &gt; 0\n          for: 15m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"Failed backend references\"\n            description: \"{{ $value }} backend references are failing validation\"\n\n    - name: cloudflare-tunnel-api\n      rules:\n        - alert: CloudflareTunnelAPIErrors\n          expr: |\n            sum(rate(cftunnel_cloudflare_api_errors_total[5m])) by (error_type) &gt; 0\n          for: 5m\n          labels:\n            severity: critical\n          annotations:\n            summary: \"Cloudflare API errors\"\n            description: \"{{ $labels.error_type }} errors: {{ $value | humanize }}/sec\"\n\n        - alert: CloudflareTunnelAPISlow\n          expr: |\n            histogram_quantile(0.99,\n              sum(rate(cftunnel_cloudflare_api_duration_seconds_bucket[5m])) by (le)\n            ) &gt; 10\n          for: 10m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"Cloudflare API latency high\"\n            description: \"P99 API latency is {{ $value | humanizeDuration }}\"\n\n        - alert: CloudflareTunnelAPIRateLimited\n          expr: |\n            sum(rate(cftunnel_cloudflare_api_errors_total{error_type=\"rate_limit\"}[5m])) &gt; 0\n          for: 2m\n          labels:\n            severity: critical\n          annotations:\n            summary: \"Cloudflare API rate limited\"\n            description: \"Controller is being rate limited by Cloudflare API\"\n\n    - name: cloudflare-tunnel-controller\n      rules:\n        - alert: CloudflareTunnelControllerHighErrorRate\n          expr: |\n            sum(rate(controller_runtime_reconcile_errors_total[5m])) by (controller)\n            /\n            sum(rate(controller_runtime_reconcile_total[5m])) by (controller)\n            &gt; 0.1\n          for: 5m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"High reconciliation error rate\"\n            description: \"Controller {{ $labels.controller }} has error rate {{ $value | humanizePercentage }}\"\n\n        - alert: CloudflareTunnelControllerSlowReconciliation\n          expr: |\n            histogram_quantile(0.99,\n              sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller)\n            ) &gt; 30\n          for: 10m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"Slow reconciliation\"\n            description: \"Controller {{ $labels.controller }} P99 latency is {{ $value | humanizeDuration }}\"\n\n        - alert: CloudflareTunnelControllerQueueBacklog\n          expr: workqueue_depth{name=~\".*gateway.*|.*httproute.*\"} &gt; 100\n          for: 5m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"Workqueue backlog\"\n            description: \"Queue {{ $labels.name }} has {{ $value }} items pending\"\n\n        - alert: CloudflareTunnelControllerDown\n          expr: up{job=\"cloudflare-tunnel-gateway-controller\"} == 0\n          for: 2m\n          labels:\n            severity: critical\n          annotations:\n            summary: \"Controller is down\"\n            description: \"Cloudflare Tunnel Gateway Controller is not responding\"\n\n        - alert: CloudflareTunnelControllerHighMemory\n          expr: |\n            process_resident_memory_bytes{job=\"cloudflare-tunnel-gateway-controller\"}\n            &gt; 512 * 1024 * 1024\n          for: 10m\n          labels:\n            severity: warning\n          annotations:\n            summary: \"High memory usage\"\n            description: \"Controller using {{ $value | humanize1024 }}B memory\"\n</code></pre>"},{"location":"operations/metrics/#grafana-dashboard","title":"Grafana Dashboard","text":"<p>Example dashboard panels:</p> <pre><code>{\n  \"title\": \"Cloudflare Tunnel Gateway Controller\",\n  \"panels\": [\n    {\n      \"title\": \"Routes Synced\",\n      \"type\": \"stat\",\n      \"gridPos\": { \"x\": 0, \"y\": 0, \"w\": 6, \"h\": 4 },\n      \"targets\": [\n        {\n          \"expr\": \"sum(cftunnel_synced_routes) by (type)\",\n          \"legendFormat\": \"{{ type }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Ingress Rules\",\n      \"type\": \"stat\",\n      \"gridPos\": { \"x\": 6, \"y\": 0, \"w\": 6, \"h\": 4 },\n      \"targets\": [\n        {\n          \"expr\": \"cftunnel_ingress_rules\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Failed Backend Refs\",\n      \"type\": \"stat\",\n      \"gridPos\": { \"x\": 12, \"y\": 0, \"w\": 6, \"h\": 4 },\n      \"targets\": [\n        {\n          \"expr\": \"sum(cftunnel_failed_backend_refs)\",\n          \"legendFormat\": \"failed\"\n        }\n      ],\n      \"fieldConfig\": {\n        \"defaults\": {\n          \"thresholds\": {\n            \"steps\": [\n              { \"value\": 0, \"color\": \"green\" },\n              { \"value\": 1, \"color\": \"red\" }\n            ]\n          }\n        }\n      }\n    },\n    {\n      \"title\": \"Sync Duration (P95)\",\n      \"type\": \"timeseries\",\n      \"gridPos\": { \"x\": 0, \"y\": 4, \"w\": 12, \"h\": 8 },\n      \"targets\": [\n        {\n          \"expr\": \"histogram_quantile(0.95, sum(rate(cftunnel_sync_duration_seconds_bucket[5m])) by (le))\",\n          \"legendFormat\": \"p95\"\n        },\n        {\n          \"expr\": \"histogram_quantile(0.50, sum(rate(cftunnel_sync_duration_seconds_bucket[5m])) by (le))\",\n          \"legendFormat\": \"p50\"\n        }\n      ],\n      \"fieldConfig\": {\n        \"defaults\": { \"unit\": \"s\" }\n      }\n    },\n    {\n      \"title\": \"Cloudflare API Latency\",\n      \"type\": \"timeseries\",\n      \"gridPos\": { \"x\": 12, \"y\": 4, \"w\": 12, \"h\": 8 },\n      \"targets\": [\n        {\n          \"expr\": \"histogram_quantile(0.99, sum(rate(cftunnel_cloudflare_api_duration_seconds_bucket[5m])) by (le, method))\",\n          \"legendFormat\": \"p99 {{ method }}\"\n        }\n      ],\n      \"fieldConfig\": {\n        \"defaults\": { \"unit\": \"s\" }\n      }\n    },\n    {\n      \"title\": \"API Calls/sec\",\n      \"type\": \"timeseries\",\n      \"gridPos\": { \"x\": 0, \"y\": 12, \"w\": 12, \"h\": 8 },\n      \"targets\": [\n        {\n          \"expr\": \"sum(rate(cftunnel_cloudflare_api_calls_total[5m])) by (method, status)\",\n          \"legendFormat\": \"{{ method }} ({{ status }})\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Sync Errors/sec\",\n      \"type\": \"timeseries\",\n      \"gridPos\": { \"x\": 12, \"y\": 12, \"w\": 12, \"h\": 8 },\n      \"targets\": [\n        {\n          \"expr\": \"sum(rate(cftunnel_sync_errors_total[5m])) by (error_type)\",\n          \"legendFormat\": \"{{ error_type }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Reconciliations/sec\",\n      \"type\": \"timeseries\",\n      \"gridPos\": { \"x\": 0, \"y\": 20, \"w\": 12, \"h\": 8 },\n      \"targets\": [\n        {\n          \"expr\": \"sum(rate(controller_runtime_reconcile_total[5m])) by (controller)\",\n          \"legendFormat\": \"{{ controller }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Reconciliation Latency\",\n      \"type\": \"timeseries\",\n      \"gridPos\": { \"x\": 12, \"y\": 20, \"w\": 12, \"h\": 8 },\n      \"targets\": [\n        {\n          \"expr\": \"histogram_quantile(0.95, sum(rate(controller_runtime_reconcile_time_seconds_bucket[5m])) by (le, controller))\",\n          \"legendFormat\": \"p95 {{ controller }}\"\n        }\n      ],\n      \"fieldConfig\": {\n        \"defaults\": { \"unit\": \"s\" }\n      }\n    },\n    {\n      \"title\": \"Queue Depth\",\n      \"type\": \"timeseries\",\n      \"gridPos\": { \"x\": 0, \"y\": 28, \"w\": 12, \"h\": 8 },\n      \"targets\": [\n        {\n          \"expr\": \"workqueue_depth\",\n          \"legendFormat\": \"{{ name }}\"\n        }\n      ]\n    },\n    {\n      \"title\": \"Memory Usage\",\n      \"type\": \"stat\",\n      \"gridPos\": { \"x\": 12, \"y\": 28, \"w\": 6, \"h\": 4 },\n      \"targets\": [\n        {\n          \"expr\": \"process_resident_memory_bytes{job=\\\"cloudflare-tunnel-gateway-controller\\\"}\"\n        }\n      ],\n      \"fieldConfig\": {\n        \"defaults\": { \"unit\": \"bytes\" }\n      }\n    },\n    {\n      \"title\": \"Goroutines\",\n      \"type\": \"stat\",\n      \"gridPos\": { \"x\": 18, \"y\": 28, \"w\": 6, \"h\": 4 },\n      \"targets\": [\n        {\n          \"expr\": \"go_goroutines{job=\\\"cloudflare-tunnel-gateway-controller\\\"}\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"operations/metrics/#health-checks","title":"Health Checks","text":""},{"location":"operations/metrics/#liveness-probe","title":"Liveness Probe","text":"<pre><code>curl http://localhost:8081/healthz\n# Returns: ok\n</code></pre>"},{"location":"operations/metrics/#readiness-probe","title":"Readiness Probe","text":"<pre><code>curl http://localhost:8081/readyz\n# Returns: ok\n</code></pre>"},{"location":"operations/metrics/#kubernetes-configuration","title":"Kubernetes Configuration","text":"<pre><code>livenessProbe:\n  httpGet:\n    path: /healthz\n    port: 8081\n  initialDelaySeconds: 15\n  periodSeconds: 20\n\nreadinessProbe:\n  httpGet:\n    path: /readyz\n    port: 8081\n  initialDelaySeconds: 5\n  periodSeconds: 10\n</code></pre>"},{"location":"operations/troubleshooting/","title":"Troubleshooting","text":"<p>This guide helps diagnose and resolve common issues with the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"operations/troubleshooting/#quick-diagnostics","title":"Quick Diagnostics","text":"<pre><code># Check controller status\nkubectl get pods --namespace cloudflare-tunnel-system\n\n# View controller logs\nkubectl logs --namespace cloudflare-tunnel-system \\\n  deployment/cloudflare-tunnel-gateway-controller\n\n# Check Gateway status\nkubectl get gateway --all-namespaces\n\n# Check HTTPRoute status\nkubectl get httproute --all-namespaces\n</code></pre>"},{"location":"operations/troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"operations/troubleshooting/#schema-validation-errors","title":"Schema Validation Errors","text":"<p>Problem: <code>values don't meet the specifications of the schema</code></p> <p>Common causes:</p> <ol> <li> <p>Empty or invalid <code>tunnelId</code>:</p> <pre><code>Error: at '/cloudflare/tunnelId': minLength: got 0, want 1\n</code></pre> <p>Solution: Provide a valid Tunnel ID from Cloudflare Zero Trust Dashboard</p> </li> <li> <p>Invalid characters in <code>tunnelId</code>:</p> <pre><code>Error: at '/cloudflare/tunnelId': pattern mismatch\n</code></pre> <p>Solution: Use only alphanumeric characters and hyphens</p> </li> <li> <p>Missing API credentials:</p> <pre><code>Error: neither apiToken nor apiTokenSecretName provided\n</code></pre> <p>Solution: Set either <code>cloudflare.apiToken</code> or <code>cloudflare.apiTokenSecretName</code></p> </li> </ol> <p>Verification:</p> <pre><code># Validate values before installation\nhelm lint charts/cloudflare-tunnel-gateway-controller --values my-values.yaml\n\n# Dry-run installation\nhelm install --dry-run --debug my-release \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --values my-values.yaml\n</code></pre>"},{"location":"operations/troubleshooting/#pod-startup-problems","title":"Pod Startup Problems","text":""},{"location":"operations/troubleshooting/#crashloopbackoff","title":"CrashLoopBackOff","text":"<p>Diagnosis:</p> <pre><code>kubectl get pods --namespace cloudflare-tunnel-system\n\nkubectl logs --namespace cloudflare-tunnel-system \\\n  deployment/cloudflare-tunnel-gateway-controller\n\nkubectl describe pod --namespace cloudflare-tunnel-system \\\n  --selector app.kubernetes.io/name=cloudflare-tunnel-gateway-controller\n</code></pre> <p>Common causes:</p> Error Cause Solution <code>authentication failed</code> Invalid API token Verify token scopes <code>secret not found</code> Missing secret Create required secret <code>read-only file system</code> Security context issue Check emptyDir volumes"},{"location":"operations/troubleshooting/#imagepullbackoff","title":"ImagePullBackOff","text":"<p>Diagnosis:</p> <pre><code>kubectl describe pod --namespace cloudflare-tunnel-system POD_NAME\n</code></pre> <p>Solutions:</p> <pre><code>image:\n  repository: ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller\n  tag: \"\"  # Uses appVersion from Chart.yaml\n  pullPolicy: IfNotPresent\n\n# For private registries\nimagePullSecrets:\n  - name: ghcr-credentials\n</code></pre>"},{"location":"operations/troubleshooting/#authentication-and-api-issues","title":"Authentication and API Issues","text":""},{"location":"operations/troubleshooting/#invalid-cloudflare-api-token","title":"Invalid Cloudflare API Token","text":"<p>Symptoms:</p> <ul> <li>Pods crash with authentication errors</li> <li>Logs show <code>401 Unauthorized</code> or <code>403 Forbidden</code></li> </ul> <p>Diagnosis:</p> <pre><code># Test API token manually\nexport CF_API_TOKEN=\"your-token\"\ncurl --header \"Authorization: Bearer $CF_API_TOKEN\" \\\n  https://api.cloudflare.com/client/v4/user/tokens/verify\n</code></pre> <p>Solution:</p> <ol> <li>Create new API token with required scopes:</li> <li> <p>Account.Cloudflare Tunnel:Edit</p> </li> <li> <p>Update secret:</p> <pre><code>kubectl create secret generic cloudflare-credentials \\\n  --from-literal=api-token=\"NEW_TOKEN\" \\\n  --namespace cloudflare-tunnel-system \\\n  --dry-run=client --output yaml | kubectl apply --filename -\n\nkubectl rollout restart deployment/cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system\n</code></pre> </li> </ol>"},{"location":"operations/troubleshooting/#network-connectivity","title":"Network Connectivity","text":""},{"location":"operations/troubleshooting/#networkpolicy-blocking-traffic","title":"NetworkPolicy Blocking Traffic","text":"<p>Symptoms:</p> <ul> <li>Metrics not accessible from Prometheus</li> <li>Health checks failing</li> <li>Cannot communicate with Cloudflare API</li> </ul> <p>Diagnosis:</p> <pre><code># Check NetworkPolicy rules\nkubectl get networkpolicy --namespace cloudflare-tunnel-system\n\n# Test connectivity from debug pod\nkubectl run debug --rm -it --image=nicolaka/netshoot \\\n  --namespace cloudflare-tunnel-system -- bash\n\n# Inside debug pod:\ncurl http://cloudflare-tunnel-gateway-controller:8080/metrics\ncurl http://cloudflare-tunnel-gateway-controller:8081/healthz\ncurl --head https://api.cloudflare.com\n</code></pre>"},{"location":"operations/troubleshooting/#dns-resolution-issues","title":"DNS Resolution Issues","text":"<p>Symptoms:</p> <ul> <li>Cannot resolve Cloudflare API endpoints</li> <li>Errors: <code>no such host</code> or <code>dial tcp: lookup failed</code></li> </ul> <p>Diagnosis:</p> <pre><code>kubectl exec --namespace cloudflare-tunnel-system POD_NAME -- \\\n  cat /etc/resolv.conf\n\nkubectl exec --namespace cloudflare-tunnel-system POD_NAME -- \\\n  nslookup api.cloudflare.com\n</code></pre> <p>Solution: Configure custom DNS</p> <pre><code>dnsPolicy: \"None\"\ndnsConfig:\n  nameservers:\n    - 1.1.1.1\n    - 8.8.8.8\n  searches:\n    - cloudflare-tunnel-system.svc.cluster.local\n    - svc.cluster.local\n    - cluster.local\n</code></pre>"},{"location":"operations/troubleshooting/#gateway-api-resources","title":"Gateway API Resources","text":""},{"location":"operations/troubleshooting/#gateway-not-ready","title":"Gateway Not Ready","text":"<p>Diagnosis:</p> <pre><code>kubectl get gateway --all-namespaces\nkubectl describe gateway my-gateway --namespace my-namespace\n\nkubectl logs --namespace cloudflare-tunnel-system \\\n  deployment/cloudflare-tunnel-gateway-controller | grep -i gateway\n</code></pre> <p>Common causes:</p> Issue Solution GatewayClass not found Set <code>gatewayClass.create: true</code> in Helm values Wrong controller name Check <code>gatewayClassName</code> matches chart configuration Service not found Verify backend Services exist"},{"location":"operations/troubleshooting/#httproute-not-attached","title":"HTTPRoute Not Attached","text":"<p>Diagnosis:</p> <pre><code>kubectl describe httproute my-route --namespace my-namespace\n</code></pre> <p>Common causes:</p> <ul> <li>Namespace mismatch (use ReferenceGrant for cross-namespace)</li> <li>Invalid hostname patterns</li> <li>Backend service not found</li> </ul>"},{"location":"operations/troubleshooting/#status-not-updating","title":"Status Not Updating","text":"<p>Problem: Gateway/HTTPRoute status conditions not updating</p> <p>Diagnosis:</p> <pre><code>kubectl auth can-i update gateways/status \\\n  --as=system:serviceaccount:cloudflare-tunnel-system:cloudflare-tunnel-gateway-controller\n</code></pre> <p>Solution: Ensure ClusterRole has status subresource permissions</p>"},{"location":"operations/troubleshooting/#amneziawg-sidecar-issues","title":"AmneziaWG Sidecar Issues","text":""},{"location":"operations/troubleshooting/#awg-interface-creation-failures","title":"AWG Interface Creation Failures","text":"<p>Symptoms:</p> <ul> <li>Container crash with <code>Operation not permitted</code></li> <li>Interface conflicts: <code>device already exists</code></li> </ul> <p>Diagnosis:</p> <pre><code>kubectl get deployment --namespace cloudflare-tunnel-system \\\n  cloudflare-tunnel-gateway-controller --output yaml | grep -A 10 securityContext\n\nkubectl logs --namespace cloudflare-tunnel-system POD_NAME --container amneziawg\n</code></pre> <p>Solutions:</p> <ol> <li> <p>AWG requires <code>NET_ADMIN</code> capability (chart handles this automatically)</p> </li> <li> <p>Use different interface prefixes for conflicts:</p> <pre><code>awg:\n  interfacePrefix: \"awg-prod\"\n</code></pre> </li> </ol>"},{"location":"operations/troubleshooting/#awg-dns-overwrites-cluster-dns","title":"AWG DNS Overwrites Cluster DNS","text":"<p>Problem: cloudflared cannot resolve internal Kubernetes services</p> <p>Symptoms:</p> <ul> <li><code>/etc/resolv.conf</code> shows VPN DNS instead of CoreDNS</li> <li>Logs show: <code>no such host</code> for internal service names</li> </ul> <p>Solution: This is handled automatically in chart version 0.2.x+. For older versions, remove <code>DNS = ...</code> line from AWG config file.</p> <p>Verification:</p> <pre><code>kubectl exec --namespace cloudflare-tunnel-system POD_NAME \\\n  --container cloudflared -- cat /etc/resolv.conf\n# Should show CoreDNS IP (e.g., 10.96.0.10), not 1.1.1.1\n</code></pre>"},{"location":"operations/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"operations/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Symptoms:</p> <ul> <li>Pods OOMKilled</li> <li>Memory usage growing over time</li> </ul> <p>Diagnosis:</p> <pre><code>kubectl top pod --namespace cloudflare-tunnel-system\n</code></pre> <p>Solution:</p> <pre><code>resources:\n  limits:\n    memory: 512Mi  # Increase from default\n  requests:\n    memory: 256Mi\n</code></pre>"},{"location":"operations/troubleshooting/#slow-reconciliation","title":"Slow Reconciliation","text":"<p>Problem: Changes to Gateway/HTTPRoute take long to apply</p> <p>Diagnosis:</p> <pre><code>kubectl logs --namespace cloudflare-tunnel-system \\\n  deployment/cloudflare-tunnel-gateway-controller | grep -i reconcil\n</code></pre> <p>Solutions:</p> <ol> <li>Check Cloudflare API rate limits in logs</li> <li>Verify network latency to Cloudflare API</li> <li>Ensure sufficient resources (CPU not throttled)</li> </ol>"},{"location":"operations/troubleshooting/#debug-logging","title":"Debug Logging","text":"<p>Enable debug logging for detailed diagnostics:</p> <pre><code>controller:\n  logLevel: \"debug\"\n  logFormat: \"json\"\n</code></pre> <pre><code>helm upgrade cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --values values.yaml \\\n  --namespace cloudflare-tunnel-system\n\nkubectl logs --follow --namespace cloudflare-tunnel-system \\\n  deployment/cloudflare-tunnel-gateway-controller\n</code></pre>"},{"location":"operations/troubleshooting/#collecting-diagnostic-information","title":"Collecting Diagnostic Information","text":"<pre><code># Pod status and events\nkubectl get pods --namespace cloudflare-tunnel-system --output wide\nkubectl describe pod --namespace cloudflare-tunnel-system POD_NAME\n\n# Recent logs\nkubectl logs --tail=100 --namespace cloudflare-tunnel-system \\\n  deployment/cloudflare-tunnel-gateway-controller\n\n# Resource usage\nkubectl top pod --namespace cloudflare-tunnel-system\n\n# Gateway API resources\nkubectl get gatewayclasses,gateways,httproutes --all-namespaces\n</code></pre>"},{"location":"operations/troubleshooting/#reporting-issues","title":"Reporting Issues","text":"<p>When reporting issues, include:</p> <ol> <li>Helm chart version: <code>helm list --namespace cloudflare-tunnel-system</code></li> <li>Kubernetes version: <code>kubectl version</code></li> <li>Cloud provider and CNI plugin</li> <li>Relevant pod logs (sanitize secrets!)</li> <li>Gateway/HTTPRoute manifests (sanitize sensitive data)</li> </ol> <p>Report issues at: https://github.com/lexfrei/cloudflare-tunnel-gateway-controller/issues</p>"},{"location":"reference/","title":"Reference","text":"<p>This section contains reference documentation for the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"reference/#sections","title":"Sections","text":"<ul> <li> <p> Helm Chart</p> <p>Complete Helm chart configuration reference.</p> <p> Helm Chart</p> </li> <li> <p> CRD Reference</p> <p>GatewayClassConfig Custom Resource Definition API reference.</p> <p> CRD Reference</p> </li> <li> <p> Security</p> <p>Security policy and vulnerability reporting.</p> <p> Security</p> </li> </ul>"},{"location":"reference/#quick-links","title":"Quick Links","text":"Resource Description GitHub Releases Release notes and changelogs Container Registry Multi-arch container images Helm Chart Registry OCI Helm chart Gateway API Docs Official Gateway API documentation Cloudflare Tunnel Docs Cloudflare Tunnel documentation"},{"location":"reference/#api-versions","title":"API Versions","text":"API Version Status GatewayClassConfig <code>cf.k8s.lex.la/v1alpha1</code> Alpha Gateway API <code>gateway.networking.k8s.io/v1</code> GA Cloudflare API v4 Stable"},{"location":"reference/crd-reference/","title":"CRD Reference","text":"<p>This document provides the API reference for Custom Resource Definitions (CRDs) used by the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"reference/crd-reference/#gatewayclassconfig","title":"GatewayClassConfig","text":"<p>API Version: <code>cf.k8s.lex.la/v1alpha1</code> Kind: <code>GatewayClassConfig</code> Scope: Cluster</p> <p>GatewayClassConfig provides tunnel configuration for the controller. It is referenced by a GatewayClass via <code>spec.parametersRef</code>.</p>"},{"location":"reference/crd-reference/#spec","title":"Spec","text":"Field Type Required Description <code>tunnelID</code> string Yes Cloudflare Tunnel UUID <code>accountID</code> string No Cloudflare Account ID (auto-detected if not specified) <code>cloudflareCredentialsSecretRef</code> SecretKeySelector Yes Reference to Secret containing API token <code>tunnelTokenSecretRef</code> SecretKeySelector Conditional Reference to Secret containing tunnel token (required when <code>cloudflared.enabled=true</code>) <code>cloudflared</code> CloudflaredSpec No cloudflared deployment configuration"},{"location":"reference/crd-reference/#cloudflaredspec","title":"CloudflaredSpec","text":"Field Type Default Description <code>enabled</code> bool <code>true</code> Deploy cloudflared via Helm <code>awg</code> AWGSpec - AmneziaWG sidecar configuration"},{"location":"reference/crd-reference/#awgspec","title":"AWGSpec","text":"Field Type Description <code>secretName</code> string Name of Secret containing AWG configuration"},{"location":"reference/crd-reference/#secretkeyselector","title":"SecretKeySelector","text":"Field Type Default Description <code>name</code> string - Secret name <code>key</code> string <code>api-token</code> or <code>tunnel-token</code> Key within the Secret"},{"location":"reference/crd-reference/#example","title":"Example","text":"<pre><code>apiVersion: cf.k8s.lex.la/v1alpha1\nkind: GatewayClassConfig\nmetadata:\n  name: cloudflare-tunnel-config\nspec:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n  # accountID: \"1234567890abcdef\"  # Optional, auto-detected\n  cloudflareCredentialsSecretRef:\n    name: cloudflare-credentials\n    key: api-token\n  tunnelTokenSecretRef:\n    name: cloudflare-tunnel-token\n    key: tunnel-token\n  cloudflared:\n    enabled: true\n    awg:\n      secretName: awg-config  # Optional\n</code></pre>"},{"location":"reference/crd-reference/#status","title":"Status","text":"<p>GatewayClassConfig does not have a status subresource.</p>"},{"location":"reference/crd-reference/#gateway-api-resources","title":"Gateway API Resources","text":"<p>The controller watches standard Gateway API resources. For their full specification, see the Gateway API documentation.</p>"},{"location":"reference/crd-reference/#gatewayclass","title":"GatewayClass","text":"<p>Standard Gateway API GatewayClass with <code>parametersRef</code> pointing to GatewayClassConfig:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: cloudflare-tunnel\nspec:\n  controllerName: cf.k8s.lex.la/tunnel-controller\n  parametersRef:\n    group: cf.k8s.lex.la\n    kind: GatewayClassConfig\n    name: cloudflare-tunnel-config\n</code></pre>"},{"location":"reference/crd-reference/#gateway","title":"Gateway","text":"<p>Standard Gateway API Gateway:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: cloudflare-tunnel\n  namespace: cloudflare-tunnel-system\nspec:\n  gatewayClassName: cloudflare-tunnel\n  listeners:\n    - name: http\n      port: 80\n      protocol: HTTP\n</code></pre>"},{"location":"reference/crd-reference/#httproute","title":"HTTPRoute","text":"<p>Standard Gateway API HTTPRoute:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: my-app\n  namespace: default\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - app.example.com\n  rules:\n    - backendRefs:\n        - name: my-service\n          port: 80\n</code></pre>"},{"location":"reference/crd-reference/#grpcroute","title":"GRPCRoute","text":"<p>Standard Gateway API GRPCRoute:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: GRPCRoute\nmetadata:\n  name: my-grpc-service\n  namespace: default\nspec:\n  parentRefs:\n    - name: cloudflare-tunnel\n      namespace: cloudflare-tunnel-system\n  hostnames:\n    - grpc.example.com\n  rules:\n    - backendRefs:\n        - name: grpc-server\n          port: 50051\n</code></pre>"},{"location":"reference/crd-reference/#referencegrant","title":"ReferenceGrant","text":"<p>Standard Gateway API ReferenceGrant for cross-namespace references:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-cross-namespace\n  namespace: backend\nspec:\n  from:\n    - group: gateway.networking.k8s.io\n      kind: HTTPRoute\n      namespace: frontend\n  to:\n    - group: \"\"\n      kind: Service\n</code></pre>"},{"location":"reference/crd-reference/#status-conditions","title":"Status Conditions","text":""},{"location":"reference/crd-reference/#gateway-status","title":"Gateway Status","text":"Condition Status Reason Description <code>Accepted</code> <code>True</code> <code>Accepted</code> Gateway accepted by controller <code>Programmed</code> <code>True</code> <code>Programmed</code> Gateway configured in Cloudflare"},{"location":"reference/crd-reference/#httproutegrpcroute-status","title":"HTTPRoute/GRPCRoute Status","text":"Condition Status Reason Description <code>Accepted</code> <code>True</code> <code>Accepted</code> Route accepted and synced <code>Accepted</code> <code>False</code> <code>NoMatchingParent</code> Sync to Cloudflare failed <code>ResolvedRefs</code> <code>True</code> <code>ResolvedRefs</code> Backend references resolved <code>ResolvedRefs</code> <code>False</code> <code>RefNotPermitted</code> Cross-namespace reference denied"},{"location":"reference/crd-reference/#api-versions","title":"API Versions","text":"Resource API Group Version Status GatewayClassConfig <code>cf.k8s.lex.la</code> <code>v1alpha1</code> Alpha GatewayClass <code>gateway.networking.k8s.io</code> <code>v1</code> GA Gateway <code>gateway.networking.k8s.io</code> <code>v1</code> GA HTTPRoute <code>gateway.networking.k8s.io</code> <code>v1</code> GA GRPCRoute <code>gateway.networking.k8s.io</code> <code>v1</code> GA ReferenceGrant <code>gateway.networking.k8s.io</code> <code>v1beta1</code> Beta"},{"location":"reference/crd-reference/#installing-crds","title":"Installing CRDs","text":""},{"location":"reference/crd-reference/#gateway-api-crds","title":"Gateway API CRDs","text":"<pre><code>kubectl apply --filename https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.4.0/standard-install.yaml\n</code></pre>"},{"location":"reference/crd-reference/#gatewayclassconfig-crd","title":"GatewayClassConfig CRD","text":"<p>Installed automatically by the Helm chart. For manual installation:</p> <pre><code>kubectl apply --filename deploy/crds/\n</code></pre>"},{"location":"reference/helm-chart/","title":"Helm Chart Reference","text":"<p>The Cloudflare Tunnel Gateway Controller is distributed as a Helm chart.</p>"},{"location":"reference/helm-chart/#installation","title":"Installation","text":"<pre><code>helm install cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --create-namespace \\\n  --values values.yaml\n</code></pre>"},{"location":"reference/helm-chart/#chart-information","title":"Chart Information","text":"Field Value Chart Name <code>cloudflare-tunnel-gateway-controller</code> Repository <code>oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart</code> Source GitHub"},{"location":"reference/helm-chart/#values-reference","title":"Values Reference","text":"<p>For the complete and up-to-date list of all configuration values, see the Helm Chart README.</p> <p>The README is auto-generated by <code>helm-docs</code> from the chart's <code>values.yaml</code> and <code>Chart.yaml</code> files.</p>"},{"location":"reference/helm-chart/#quick-reference","title":"Quick Reference","text":""},{"location":"reference/helm-chart/#essential-values","title":"Essential Values","text":"<pre><code># Tunnel configuration\nconfig:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"  # Required\n  apiToken: \"your-api-token\"                         # Or use existingSecrets\n  tunnelToken: \"your-tunnel-token\"                   # Required for cloudflared\n</code></pre>"},{"location":"reference/helm-chart/#using-existing-secrets","title":"Using Existing Secrets","text":"<pre><code>config:\n  tunnelID: \"550e8400-e29b-41d4-a716-446655440000\"\n  existingSecrets:\n    apiToken:\n      name: cloudflare-credentials\n      key: api-token\n    tunnelToken:\n      name: cloudflare-tunnel-token\n      key: tunnel-token\n</code></pre>"},{"location":"reference/helm-chart/#high-availability","title":"High Availability","text":"<pre><code>controller:\n  replicas: 2\n  leaderElection:\n    enabled: true\n\ncloudflared:\n  replicas: 2\n\npodDisruptionBudget:\n  enabled: true\n  minAvailable: 1\n</code></pre>"},{"location":"reference/helm-chart/#monitoring","title":"Monitoring","text":"<pre><code>serviceMonitor:\n  enabled: true\n  interval: 30s\n  labels:\n    release: prometheus\n</code></pre>"},{"location":"reference/helm-chart/#amneziawg-sidecar","title":"AmneziaWG Sidecar","text":"<pre><code>cloudflared:\n  awg:\n    enabled: true\n    secretName: awg-config\n</code></pre>"},{"location":"reference/helm-chart/#example-values-files","title":"Example Values Files","text":"<p>The chart includes example values files in the <code>examples/</code> directory:</p> File Description <code>basic-values.yaml</code> Minimal configuration <code>ha-values.yaml</code> High availability setup <code>external-secrets-values.yaml</code> External Secrets Operator integration <code>awg-values.yaml</code> AmneziaWG sidecar configuration"},{"location":"reference/helm-chart/#upgrading","title":"Upgrading","text":"<pre><code>helm upgrade cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --namespace cloudflare-tunnel-system \\\n  --values values.yaml\n</code></pre>"},{"location":"reference/helm-chart/#version-pinning","title":"Version Pinning","text":"<p>Pin to specific versions in production:</p> <pre><code>helm upgrade cloudflare-tunnel-gateway-controller \\\n  oci://ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller/chart \\\n  --version 0.8.0 \\\n  --namespace cloudflare-tunnel-system \\\n  --values values.yaml\n</code></pre>"},{"location":"reference/helm-chart/#uninstalling","title":"Uninstalling","text":"<pre><code>helm uninstall cloudflare-tunnel-gateway-controller \\\n  --namespace cloudflare-tunnel-system\n</code></pre> <p>Cleanup</p> <p>Uninstalling the Helm release removes the controller and cloudflared pods. The tunnel configuration in Cloudflare will remain. To fully clean up, delete the tunnel from the Cloudflare dashboard.</p>"},{"location":"reference/helm-chart/#crds","title":"CRDs","text":"<p>The chart installs the GatewayClassConfig CRD. Gateway API CRDs must be installed separately:</p> <pre><code>kubectl apply --filename https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.4.0/standard-install.yaml\n</code></pre>"},{"location":"reference/helm-chart/#dependencies","title":"Dependencies","text":"<p>The controller uses the cloudflare-tunnel Helm chart to deploy cloudflared when <code>cloudflared.enabled: true</code>.</p>"},{"location":"reference/helm-chart/#helm-chart-testing","title":"Helm Chart Testing","text":"<p>Test the chart locally:</p> <pre><code># Lint\nhelm lint charts/cloudflare-tunnel-gateway-controller\n\n# Template\nhelm template test charts/cloudflare-tunnel-gateway-controller \\\n  --values charts/cloudflare-tunnel-gateway-controller/examples/basic-values.yaml\n\n# Unit tests\nhelm unittest charts/cloudflare-tunnel-gateway-controller\n</code></pre>"},{"location":"reference/security/","title":"Security","text":"<p>This document covers the security policy and best practices for the Cloudflare Tunnel Gateway Controller.</p>"},{"location":"reference/security/#supported-versions","title":"Supported Versions","text":"Version Supported 0.x.x Yes"},{"location":"reference/security/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>Do Not Use Public Issues</p> <p>Please do not report security vulnerabilities through public GitHub issues.</p> <p>Report vulnerabilities via email:</p> <ul> <li>Email: f@lex.la</li> <li>GPG Key: <code>F57F 85FC 7975 F22B BC3F 2504 9C17 3EB1 B531 AA1F</code></li> </ul>"},{"location":"reference/security/#what-to-include","title":"What to Include","text":"<ul> <li>Type of vulnerability</li> <li>Full paths of affected source files</li> <li>Location of affected source code (tag/branch/commit)</li> <li>Step-by-step reproduction instructions</li> <li>Proof-of-concept or exploit code (if possible)</li> <li>Impact assessment</li> </ul>"},{"location":"reference/security/#response-timeline","title":"Response Timeline","text":"Stage Timeline Initial Response Within 48 hours Status Update Within 7 days Fix Timeline Depends on severity"},{"location":"reference/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"reference/security/#api-token-management","title":"API Token Management","text":"<p>The Cloudflare API token is sensitive and should be:</p> <ol> <li> <p>Stored in Kubernetes Secret</p> <pre><code>kubectl create secret generic cloudflare-credentials \\\n  --from-literal=api-token=\"${CF_API_TOKEN}\"\n</code></pre> </li> <li> <p>Scoped with minimum permissions</p> </li> <li> <p>Account: Cloudflare Tunnel (Edit, Read)</p> </li> <li> <p>Rotated regularly</p> </li> <li>Create new token in Cloudflare dashboard</li> <li>Update Kubernetes secret</li> <li> <p>Controller picks up new token on restart</p> </li> <li> <p>Never committed to git</p> </li> <li>Use external secret management (Vault, AWS Secrets Manager)</li> </ol>"},{"location":"reference/security/#rbac-configuration","title":"RBAC Configuration","text":"<p>The controller requires specific Kubernetes permissions:</p> <pre><code># Minimum required permissions\nrules:\n  # Gateway API - read specs, write status\n  - apiGroups: [\"gateway.networking.k8s.io\"]\n    resources: [\"gateways\", \"httproutes\", \"grpcroutes\", \"gatewayclasses\", \"referencegrants\"]\n    verbs: [\"get\", \"list\", \"watch\"]\n  - apiGroups: [\"gateway.networking.k8s.io\"]\n    resources: [\"gateways/status\", \"httproutes/status\", \"grpcroutes/status\"]\n    verbs: [\"get\", \"update\", \"patch\"]\n\n  # Services - read only for backend resolution\n  - apiGroups: [\"\"]\n    resources: [\"services\"]\n    verbs: [\"get\", \"list\", \"watch\"]\n\n  # Leader election\n  - apiGroups: [\"coordination.k8s.io\"]\n    resources: [\"leases\"]\n    verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"]\n</code></pre>"},{"location":"reference/security/#container-security","title":"Container Security","text":"<p>The controller container follows security best practices:</p> Setting Value Rationale <code>runAsNonRoot</code> <code>true</code> Never run as root <code>runAsUser</code> <code>65534</code> nobody user <code>readOnlyRootFilesystem</code> <code>true</code> Prevent filesystem modifications <code>allowPrivilegeEscalation</code> <code>false</code> Prevent privilege escalation <code>capabilities.drop</code> <code>ALL</code> Drop all Linux capabilities <code>seccompProfile.type</code> <code>RuntimeDefault</code> Use default seccomp profile"},{"location":"reference/security/#network-security","title":"Network Security","text":""},{"location":"reference/security/#egress-requirements","title":"Egress Requirements","text":"<p>The controller only needs egress to:</p> Destination Port Purpose <code>api.cloudflare.com</code> 443 Cloudflare API Kubernetes API 443/6443 Watch resources"},{"location":"reference/security/#networkpolicy-example","title":"NetworkPolicy Example","text":"<pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: cloudflare-tunnel-gateway-controller\nspec:\n  podSelector:\n    matchLabels:\n      app.kubernetes.io/name: cloudflare-tunnel-gateway-controller\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    # Prometheus scraping\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: monitoring\n      ports:\n        - port: 8080\n  egress:\n    # Kubernetes API and Cloudflare API\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n      ports:\n        - port: 443\n        - port: 6443\n    # DNS\n    - to: []\n      ports:\n        - port: 53\n          protocol: UDP\n</code></pre>"},{"location":"reference/security/#supply-chain-security","title":"Supply Chain Security","text":""},{"location":"reference/security/#container-image-verification","title":"Container Image Verification","text":"<p>Container images are signed with cosign (keyless):</p> <pre><code>cosign verify ghcr.io/lexfrei/cloudflare-tunnel-gateway-controller:latest \\\n  --certificate-identity-regexp=\"https://github.com/lexfrei/cloudflare-tunnel-gateway-controller\" \\\n  --certificate-oidc-issuer=\"https://token.actions.githubusercontent.com\"\n</code></pre>"},{"location":"reference/security/#helm-chart-verification","title":"Helm Chart Verification","text":"<pre><code>helm verify cloudflare-tunnel-gateway-controller-0.1.0.tgz\n</code></pre>"},{"location":"reference/security/#secrets-in-logs","title":"Secrets in Logs","text":"<p>The controller is designed to never log sensitive information:</p> <ul> <li>API tokens are not logged</li> <li>Tunnel tokens are not logged</li> <li>Secret contents are not logged</li> </ul> <p>Report Log Leaks</p> <p>If you find sensitive data in logs, please report it as a security issue.</p>"},{"location":"reference/security/#security-scanning","title":"Security Scanning","text":"<p>The project uses automated security scanning:</p> Tool Purpose Trivy Vulnerability scanning in CI gosec Go security linter Dependabot/Renovate Dependency updates"},{"location":"reference/security/#incident-response","title":"Incident Response","text":"<p>If you believe the controller has been compromised:</p> <ol> <li>Revoke Cloudflare API token immediately</li> <li>Delete the controller deployment</li> <li>Review Cloudflare audit logs for unauthorized changes</li> <li>Rotate tunnel credentials if needed</li> <li>Report the incident via security email</li> </ol>"},{"location":"reference/security/#secure-deployment-checklist","title":"Secure Deployment Checklist","text":"<ul> <li> API token stored in Kubernetes Secret (not in values.yaml)</li> <li> API token has minimal required permissions</li> <li> Controller running as non-root</li> <li> Read-only root filesystem enabled</li> <li> NetworkPolicy restricting egress</li> <li> ServiceAccount with minimal RBAC</li> <li> Container image verified with cosign</li> <li> Prometheus monitoring enabled</li> <li> Alerts configured for anomalous behavior</li> </ul>"}]}